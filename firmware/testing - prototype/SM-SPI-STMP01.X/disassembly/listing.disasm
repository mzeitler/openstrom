Disassembly Listing for SM-SPI-STMP01
Generated From:
D:/PLIB-Project/SM-SPI-STMP01.X/dist/default/debug/SM-SPI-STMP01.X.debug.elf
01.09.2016 15:46:39

---  d:/plib-project/sm-spi-stmp01.x/main.c  ------------------------------------------------------------
1:                   /* 
2:                    * File:   main.c
3:                    * Author: Anton Tachev
4:                    * Description: The test function SM-SPI-STMP01 configurates STPM 34 IC in
5:                    * fundamental mode and reads the following parameters:
6:                    * -Active Energy;
7:                    * -Reactive Energy
8:                    * Created on 09.Jan 2016
9:                    */
10:                  /*SPI 2 module identification                                                */
11:                  /* SCK2 - pin2 RE6                         
12:                   * SDI2 - pin5 RG7
13:                   * SDO2 - pin 6 RG8
14:                   * SCS - pin 9 RG9
15:                   * Enable(EN) - pin 45 RD11
16:                   * Enable(EN) - pin 45 RD11
17:                   */
18:                  /*-------------------------------------------------------------------------------*/
19:                  /* PORT/pin Definitions:                                                         */
20:                  /* En   - PIC32-pin45    RD11                                                    */
21:                  /* CS_1 - PIC32-pin8     RG9                                                     */
22:                  /* CS_2 - PIC32-pin11    RG5                                                     */
23:                  /* CS_3 - PIC32-pin12    RB4                                                     */
24:                  /* CS_4 - PIC32-pin14    RB2                                                     */
25:                  /* CS_5 - PIC32-pin13    RB3                                                     */
26:                  /**/
27:                  /* SPI Bus Pins Definition                                                       */
28:                  /* SKL2 - PIC32-pin2 - RE6                                                       */
29:                  /* SDI2 - PIC32-pin5 - RG7                                                       */
30:                  /* SDO2 - PIC32-pin6 - RG8                                                       */
31:                  /*-------------------------------------------------------------------------------*/
32:                  #include <stdio.h>
33:                  #include <stdlib.h>
34:                  #include <stdint.h>
35:                  #include <plib.h>
36:                  #include <p32xxxx.h>
37:                  //#include <STPM34_header.h>
38:                  #include "STPM-define.h"
39:                  /*----------------Function prototypes -----------------------------------------*/
40:                  
41:                  void  Init_STPM34();        //function prototype ale defined in STPm34_header.h
42:                  void  SPI_Init();
43:                  void Delay(void);
44:                  void ReadFrame(unsigned int address, unsigned int* buffer, short int csNum);
45:                  void SendFrame(char readAdd,char writeAdd, char dataLSB,char dataMSB,short int csNum);
46:                  void SetCSpin(int csNUM);
47:                  
48:                  unsigned int csNum;
49:                  // configuration settings
50:                  
51:                  #pragma config FPLLMUL = MUL_20, FPLLIDIV = DIV_2, FPLLODIV = DIV_8, FWDTEN = OFF
52:                  #pragma config POSCMOD = HS, FNOSC = PRIPLL, FPBDIV = DIV_1
53:                  int i,j,k;
54:                  int delayValue;
55:                  unsigned int csNum;
56:                  
57:                   
58:                    int main()
59:                    {
9D000000  27BDFFB0   ADDIU SP, SP, -80
9D000004  AFBF004C   SW RA, 76(SP)
9D000008  AFBE0048   SW S8, 72(SP)
9D00000C  03A0F021   ADDU S8, SP, ZERO
9D000010  3C0204C4   LUI V0, 1220
9D000014  3442B400   ORI V0, V0, -19456
9D000018  AFC20010   SW V0, 16(S8)
9D00001C  8FC20010   LW V0, 16(S8)
9D000020  AFC20014   SW V0, 20(S8)
60:                     
61:                    // configure the proper PB frequency and the number of wait states
62:                      SYSTEMConfigWaitStatesAndPB(80000000L);
63:                      CheKseg0CacheOn();                           // enable the cache for the best performance 
9D00021C  0F40074C   JAL CheKseg0CacheOn
9D000220  00000000   NOP
64:                      
65:                      SPI_Init();
9D000224  0F40013C   JAL SPI_Init
9D000228  00000000   NOP
66:                      Init_STPM34();
9D00022C  0F400188   JAL Init_STPM34
9D000230  00000000   NOP
67:                   
68:                      while(1)
69:                      {
70:                       
71:                        //1. Read Current and Voltage parameters from Chn1:
72:                        // - V1_Data[23:0] from dsp_reg2
73:                          
74:                          parm_Reg[0].Address=V1_Data_Address;
9D000234  9783801A   LHU V1, -32742(GP)
9D000238  3C02A000   LUI V0, -24576
9D00023C  24420640   ADDIU V0, V0, 1600
9D000240  A4430006   SH V1, 6(V0)
75:                          parm_Reg[0].dataBuffer=Chn_Buffer1;
9D000244  3C02A000   LUI V0, -24576
9D000248  3C03A000   LUI V1, -24576
9D00024C  246304B0   ADDIU V1, V1, 1200
9D000250  AC430640   SW V1, 1600(V0)
76:                          csNum=1;
9D000254  24020001   ADDIU V0, ZERO, 1
9D000258  AF8280C4   SW V0, -32572(GP)
77:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D00025C  3C02A000   LUI V0, -24576
9D000260  24420640   ADDIU V0, V0, 1600
9D000264  94420006   LHU V0, 6(V0)
9D000268  00401821   ADDU V1, V0, ZERO
9D00026C  3C02A000   LUI V0, -24576
9D000270  8C420640   LW V0, 1600(V0)
9D000274  00602021   ADDU A0, V1, ZERO
9D000278  00402821   ADDU A1, V0, ZERO
9D00027C  24060001   ADDIU A2, ZERO, 1
9D000280  0F4002CB   JAL ReadFrame
9D000284  00000000   NOP
78:                        //-C1_Data[23:0] from dsp reg3
79:                           
80:                          parm_Reg[0].Address=C1_Data_Address;
9D000288  9783801E   LHU V1, -32738(GP)
9D00028C  3C02A000   LUI V0, -24576
9D000290  24420640   ADDIU V0, V0, 1600
9D000294  A4430006   SH V1, 6(V0)
81:                          parm_Reg[0].dataBuffer=Chn_Buffer1;
9D000298  3C02A000   LUI V0, -24576
9D00029C  3C03A000   LUI V1, -24576
9D0002A0  246304B0   ADDIU V1, V1, 1200
9D0002A4  AC430640   SW V1, 1600(V0)
82:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D0002A8  3C02A000   LUI V0, -24576
9D0002AC  24420640   ADDIU V0, V0, 1600
9D0002B0  94420006   LHU V0, 6(V0)
9D0002B4  00401821   ADDU V1, V0, ZERO
9D0002B8  3C02A000   LUI V0, -24576
9D0002BC  8C420640   LW V0, 1600(V0)
9D0002C0  00602021   ADDU A0, V1, ZERO
9D0002C4  00402821   ADDU A1, V0, ZERO
9D0002C8  24060001   ADDIU A2, ZERO, 1
9D0002CC  0F4002CB   JAL ReadFrame
9D0002D0  00000000   NOP
83:                      
84:                         //2. Read Current and Voltage parameters from Chn2:
85:                        // - V2_Data[23:0] from dsp_reg4
86:                          
87:                          parm_Reg[0].Address=V2_Data_Address;
9D0002D4  97838022   LHU V1, -32734(GP)
9D0002D8  3C02A000   LUI V0, -24576
9D0002DC  24420640   ADDIU V0, V0, 1600
9D0002E0  A4430006   SH V1, 6(V0)
88:                          parm_Reg[0].dataBuffer=Chn_Buffer2;
9D0002E4  3C02A000   LUI V0, -24576
9D0002E8  3C03A000   LUI V1, -24576
9D0002EC  24630410   ADDIU V1, V1, 1040
9D0002F0  AC430640   SW V1, 1600(V0)
89:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D0002F4  3C02A000   LUI V0, -24576
9D0002F8  24420640   ADDIU V0, V0, 1600
9D0002FC  94420006   LHU V0, 6(V0)
9D000300  00401821   ADDU V1, V0, ZERO
9D000304  3C02A000   LUI V0, -24576
9D000308  8C420640   LW V0, 1600(V0)
9D00030C  00602021   ADDU A0, V1, ZERO
9D000310  00402821   ADDU A1, V0, ZERO
9D000314  24060001   ADDIU A2, ZERO, 1
9D000318  0F4002CB   JAL ReadFrame
9D00031C  00000000   NOP
90:                           //-C2_Data[23:0] from dsp reg5
91:                           
92:                          parm_Reg[0].Address=C2_Data_Address;
9D000320  97838026   LHU V1, -32730(GP)
9D000324  3C02A000   LUI V0, -24576
9D000328  24420640   ADDIU V0, V0, 1600
9D00032C  A4430006   SH V1, 6(V0)
93:                          parm_Reg[0].dataBuffer=Chn_Buffer2;
9D000330  3C02A000   LUI V0, -24576
9D000334  3C03A000   LUI V1, -24576
9D000338  24630410   ADDIU V1, V1, 1040
9D00033C  AC430640   SW V1, 1600(V0)
94:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D000340  3C02A000   LUI V0, -24576
9D000344  24420640   ADDIU V0, V0, 1600
9D000348  94420006   LHU V0, 6(V0)
9D00034C  00401821   ADDU V1, V0, ZERO
9D000350  3C02A000   LUI V0, -24576
9D000354  8C420640   LW V0, 1600(V0)
9D000358  00602021   ADDU A0, V1, ZERO
9D00035C  00402821   ADDU A1, V0, ZERO
9D000360  24060001   ADDIU A2, ZERO, 1
9D000364  0F4002CB   JAL ReadFrame
9D000368  00000000   NOP
95:                           
96:                           //3. Read Fund Current and Fund Voltage parameters from Chn1:
97:                        // - V1_Fund[23:0] from dsp_reg6
98:                          parm_Reg[0].Address=V1_Fund_Address;
9D00036C  9783802A   LHU V1, -32726(GP)
9D000370  3C02A000   LUI V0, -24576
9D000374  24420640   ADDIU V0, V0, 1600
9D000378  A4430006   SH V1, 6(V0)
99:                          parm_Reg[0].dataBuffer=Chn_Buffer1;
9D00037C  3C02A000   LUI V0, -24576
9D000380  3C03A000   LUI V1, -24576
9D000384  246304B0   ADDIU V1, V1, 1200
9D000388  AC430640   SW V1, 1600(V0)
100:                         ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D00038C  3C02A000   LUI V0, -24576
9D000390  24420640   ADDIU V0, V0, 1600
9D000394  94420006   LHU V0, 6(V0)
9D000398  00401821   ADDU V1, V0, ZERO
9D00039C  3C02A000   LUI V0, -24576
9D0003A0  8C420640   LW V0, 1600(V0)
9D0003A4  00602021   ADDU A0, V1, ZERO
9D0003A8  00402821   ADDU A1, V0, ZERO
9D0003AC  24060001   ADDIU A2, ZERO, 1
9D0003B0  0F4002CB   JAL ReadFrame
9D0003B4  00000000   NOP
101:                         
102:                       //-C1_Fund[23:0] from dsp reg7
103:                          
104:                          parm_Reg[0].Address=C1_Fund_Address;
9D0003B8  9783802E   LHU V1, -32722(GP)
9D0003BC  3C02A000   LUI V0, -24576
9D0003C0  24420640   ADDIU V0, V0, 1600
9D0003C4  A4430006   SH V1, 6(V0)
105:                          parm_Reg[0].dataBuffer=Chn_Buffer1;
9D0003C8  3C02A000   LUI V0, -24576
9D0003CC  3C03A000   LUI V1, -24576
9D0003D0  246304B0   ADDIU V1, V1, 1200
9D0003D4  AC430640   SW V1, 1600(V0)
106:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D0003D8  3C02A000   LUI V0, -24576
9D0003DC  24420640   ADDIU V0, V0, 1600
9D0003E0  94420006   LHU V0, 6(V0)
9D0003E4  00401821   ADDU V1, V0, ZERO
9D0003E8  3C02A000   LUI V0, -24576
9D0003EC  8C420640   LW V0, 1600(V0)
9D0003F0  00602021   ADDU A0, V1, ZERO
9D0003F4  00402821   ADDU A1, V0, ZERO
9D0003F8  24060001   ADDIU A2, ZERO, 1
9D0003FC  0F4002CB   JAL ReadFrame
9D000400  00000000   NOP
107:                     
108:                        //2. Read Fund Current and Fund Voltage parameters from Chn2:
109:                       // - V2_Fund[23:0] from dsp_reg8
110:                         
111:                         parm_Reg[0].Address=V2_Fund_Address;
9D000404  97838032   LHU V1, -32718(GP)
9D000408  3C02A000   LUI V0, -24576
9D00040C  24420640   ADDIU V0, V0, 1600
9D000410  A4430006   SH V1, 6(V0)
112:                         parm_Reg[0].dataBuffer=Chn_Buffer2;
9D000414  3C02A000   LUI V0, -24576
9D000418  3C03A000   LUI V1, -24576
9D00041C  24630410   ADDIU V1, V1, 1040
9D000420  AC430640   SW V1, 1600(V0)
113:                         ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D000424  3C02A000   LUI V0, -24576
9D000428  24420640   ADDIU V0, V0, 1600
9D00042C  94420006   LHU V0, 6(V0)
9D000430  00401821   ADDU V1, V0, ZERO
9D000434  3C02A000   LUI V0, -24576
9D000438  8C420640   LW V0, 1600(V0)
9D00043C  00602021   ADDU A0, V1, ZERO
9D000440  00402821   ADDU A1, V0, ZERO
9D000444  24060001   ADDIU A2, ZERO, 1
9D000448  0F4002CB   JAL ReadFrame
9D00044C  00000000   NOP
114:                         
115:                          //-C2_Fund[23:0] from dsp reg9
116:                          
117:                          parm_Reg[0].Address=C2_Fund_Address;
9D000450  97838036   LHU V1, -32714(GP)
9D000454  3C02A000   LUI V0, -24576
9D000458  24420640   ADDIU V0, V0, 1600
9D00045C  A4430006   SH V1, 6(V0)
118:                          parm_Reg[0].dataBuffer=Chn_Buffer2;
9D000460  3C02A000   LUI V0, -24576
9D000464  3C03A000   LUI V1, -24576
9D000468  24630410   ADDIU V1, V1, 1040
9D00046C  AC430640   SW V1, 1600(V0)
119:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D000470  3C02A000   LUI V0, -24576
9D000474  24420640   ADDIU V0, V0, 1600
9D000478  94420006   LHU V0, 6(V0)
9D00047C  00401821   ADDU V1, V0, ZERO
9D000480  3C02A000   LUI V0, -24576
9D000484  8C420640   LW V0, 1600(V0)
9D000488  00602021   ADDU A0, V1, ZERO
9D00048C  00402821   ADDU A1, V0, ZERO
9D000490  24060001   ADDIU A2, ZERO, 1
9D000494  0F4002CB   JAL ReadFrame
9D000498  00000000   NOP
120:                          
121:                          // PH1 Fundamental Energy ph1_reg2
122:                          parm_Reg[0].Address=PH1_Fundamental_Energy_Address;
9D00049C  97838042   LHU V1, -32702(GP)
9D0004A0  3C02A000   LUI V0, -24576
9D0004A4  24420640   ADDIU V0, V0, 1600
9D0004A8  A4430006   SH V1, 6(V0)
123:                          parm_Reg[0].dataBuffer=Chn_Buffer1;
9D0004AC  3C02A000   LUI V0, -24576
9D0004B0  3C03A000   LUI V1, -24576
9D0004B4  246304B0   ADDIU V1, V1, 1200
9D0004B8  AC430640   SW V1, 1600(V0)
124:                          ReadFrame(parm_Reg[0].Address,parm_Reg[0].dataBuffer,1);
9D0004BC  3C02A000   LUI V0, -24576
9D0004C0  24420640   ADDIU V0, V0, 1600
9D0004C4  94420006   LHU V0, 6(V0)
9D0004C8  00401821   ADDU V1, V0, ZERO
9D0004CC  3C02A000   LUI V0, -24576
9D0004D0  8C420640   LW V0, 1600(V0)
9D0004D4  00602021   ADDU A0, V1, ZERO
9D0004D8  00402821   ADDU A1, V0, ZERO
9D0004DC  24060001   ADDIU A2, ZERO, 1
9D0004E0  0F4002CB   JAL ReadFrame
9D0004E4  00000000   NOP
125:                          
126:                     }
9D0004E8  0B40008D   J 0x9D000234
9D0004EC  00000000   NOP
127:                     
128:                 }
129:                 void SPI_Init()
130:                 
131:                 {
9D0004F0  27BDFFE8   ADDIU SP, SP, -24
9D0004F4  AFBF0014   SW RA, 20(SP)
9D0004F8  AFBE0010   SW S8, 16(SP)
9D0004FC  03A0F021   ADDU S8, SP, ZERO
132:                     AD1PCFG=0xffff;                      // set PORTB RBx pins as digital outputs
9D000500  3C02BF81   LUI V0, -16511
9D000504  3403FFFF   ORI V1, ZERO, -1
9D000508  AC439060   SW V1, -28576(V0)
133:                    // Set Inputs/Outputs for SPI communication
134:                    // Option 1
135:                     TRISDbits.TRISD11=0;           //set EN as Output
9D00050C  3C03BF88   LUI V1, -16504
9D000510  946260C0   LHU V0, 24768(V1)
9D000514  7C025AC4   INS V0, ZERO, 11, 1
9D000518  A46260C0   SH V0, 24768(V1)
136:                     TRISGbits.TRISG9=0;            // set CS_1 output
9D00051C  3C03BF88   LUI V1, -16504
9D000520  94626180   LHU V0, 24960(V1)
9D000524  7C024A44   INS V0, ZERO, 9, 1
9D000528  A4626180   SH V0, 24960(V1)
137:                     TRISBbits.TRISB5=0;            // set CS_2 output
9D00052C  3C03BF88   LUI V1, -16504
9D000530  94626040   LHU V0, 24640(V1)
9D000534  7C022944   INS V0, ZERO, 5, 1
9D000538  A4626040   SH V0, 24640(V1)
138:                     TRISBbits.TRISB4=0;            // set CS_3 output
9D00053C  3C03BF88   LUI V1, -16504
9D000540  94626040   LHU V0, 24640(V1)
9D000544  7C022104   INS V0, ZERO, 4, 1
9D000548  A4626040   SH V0, 24640(V1)
139:                     TRISBbits.TRISB2=0;            // set CS_4 output
9D00054C  3C03BF88   LUI V1, -16504
9D000550  94626040   LHU V0, 24640(V1)
9D000554  7C021084   INS V0, ZERO, 2, 1
9D000558  A4626040   SH V0, 24640(V1)
140:                     TRISBbits.TRISB3=0;            // set CS_5 output
9D00055C  3C03BF88   LUI V1, -16504
9D000560  94626040   LHU V0, 24640(V1)
9D000564  7C0218C4   INS V0, ZERO, 3, 1
9D000568  A4626040   SH V0, 24640(V1)
141:                    
142:                     //Option2 (macros))
143:                     
144:                     mPORTDSetPinsDigitalOut(BIT_11);
9D00056C  3C02BF88   LUI V0, -16504
9D000570  24030800   ADDIU V1, ZERO, 2048
9D000574  AC4360C4   SW V1, 24772(V0)
145:                     mPORTGSetPinsDigitalOut(BIT_9);
9D000578  3C02BF88   LUI V0, -16504
9D00057C  24030200   ADDIU V1, ZERO, 512
9D000580  AC436184   SW V1, 24964(V0)
146:                     mPORTBSetPinsDigitalOut(BIT_2|BIT_3|BIT_4|BIT_5);
9D000584  3C02BF88   LUI V0, -16504
9D000588  2403003C   ADDIU V1, ZERO, 60
9D00058C  AC436044   SW V1, 24644(V0)
9D000590  3C02BF81   LUI V0, -16511
9D000594  2403003C   ADDIU V1, ZERO, 60
9D000598  AC439068   SW V1, -28568(V0)
147:                     
148:                     /*    Set SPI Bus pins                           */
149:                     //Option1
150:                     TRISEbits.TRISE6=0;                //SCL2 output
9D00059C  3C03BF88   LUI V1, -16504
9D0005A0  90626100   LBU V0, 24832(V1)
9D0005A4  7C023184   INS V0, ZERO, 6, 1
9D0005A8  A0626100   SB V0, 24832(V1)
151:                     TRISGbits.TRISG7=1;                //SDI2 - input(MISO)
9D0005AC  3C03BF88   LUI V1, -16504
9D0005B0  94626180   LHU V0, 24960(V1)
9D0005B4  24040001   ADDIU A0, ZERO, 1
9D0005B8  7C8239C4   INS V0, A0, 7, 1
9D0005BC  A4626180   SH V0, 24960(V1)
152:                     TRISGbits.TRISG8=0;                // SDO2 - output(MOSI)
9D0005C0  3C03BF88   LUI V1, -16504
9D0005C4  94626180   LHU V0, 24960(V1)
9D0005C8  7C024204   INS V0, ZERO, 8, 1
9D0005CC  A4626180   SH V0, 24960(V1)
153:                     
154:                     //Option 2 
155:                     mPORTESetPinsDigitalOut(BIT_6);
9D0005D0  3C02BF88   LUI V0, -16504
9D0005D4  24030040   ADDIU V1, ZERO, 64
9D0005D8  AC436104   SW V1, 24836(V0)
156:                     mPORTGSetPinsDigitalIn(BIT_7);
9D0005DC  3C02BF88   LUI V0, -16504
9D0005E0  24030080   ADDIU V1, ZERO, 128
9D0005E4  AC436188   SW V1, 24968(V0)
157:                     mPORTGSetPinsDigitalOut(BIT_8);
9D0005E8  3C02BF88   LUI V0, -16504
9D0005EC  24030100   ADDIU V1, ZERO, 256
9D0005F0  AC436184   SW V1, 24964(V0)
158:                     
159:                     //Open SPI_2 Object
160:                     SpiChnOpen(2,SPICON_MSTEN|SPICON_SMP|SPICON_MODE16|SPICON_ON,4);
9D0005F4  24040002   ADDIU A0, ZERO, 2
9D0005F8  34058620   ORI A1, ZERO, -31200
9D0005FC  24060004   ADDIU A2, ZERO, 4
9D000600  0F400550   JAL SpiChnOpen
9D000604  00000000   NOP
161:                     }
9D000608  03C0E821   ADDU SP, S8, ZERO
9D00060C  8FBF0014   LW RA, 20(SP)
9D000610  8FBE0010   LW S8, 16(SP)
9D000614  27BD0018   ADDIU SP, SP, 24
9D000618  03E00008   JR RA
9D00061C  00000000   NOP
162:                 void  Init_STPM34()
163:                 {
9D000620  27BDFFE0   ADDIU SP, SP, -32
9D000624  AFBF001C   SW RA, 28(SP)
9D000628  AFBE0018   SW S8, 24(SP)
9D00062C  03A0F021   ADDU S8, SP, ZERO
164:                    
165:                     //set Voltage Reference
166:                    
167:                     DSP_CR100bits.ENVREF1=1;         //enable Vref1 bit for CH0;  
9D000630  978280E4   LHU V0, -32540(GP)
9D000634  24030001   ADDIU V1, ZERO, 1
9D000638  7C622944   INS V0, V1, 5, 1
9D00063C  A78280E4   SH V0, -32540(GP)
168:                     DSP_CR100bits.TC1=0x2;           //set temperature compensation for CH0; Vref1=1.18v default
9D000640  978280E4   LHU V0, -32540(GP)
9D000644  24030002   ADDIU V1, ZERO, 2
9D000648  7C624184   INS V0, V1, 6, 3
9D00064C  A78280E4   SH V0, -32540(GP)
169:                     
170:                     readAdd=0x00;
9D000650  A38080FC   SB ZERO, -32516(GP)
171:                     writeAdd=0x00; 
9D000654  A38080C8   SB ZERO, -32568(GP)
172:                     dataLSB=DSP_CR100bits.LSB;
9D000658  938280E4   LBU V0, -32540(GP)
9D00065C  7C021420   SEB V0, V0
9D000660  A38280F0   SB V0, -32528(GP)
173:                     dataMSB=DSP_CR100bits.MSB;
9D000664  938280E5   LBU V0, -32539(GP)
9D000668  7C021420   SEB V0, V0
9D00066C  A3828110   SB V0, -32496(GP)
174:                   
175:                     SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);    //write to  CR1 register
9D000670  838280FC   LB V0, -32516(GP)
9D000674  00402021   ADDU A0, V0, ZERO
9D000678  838280C8   LB V0, -32568(GP)
9D00067C  00402821   ADDU A1, V0, ZERO
9D000680  838280F0   LB V0, -32528(GP)
9D000684  00401821   ADDU V1, V0, ZERO
9D000688  83828110   LB V0, -32496(GP)
9D00068C  24060001   ADDIU A2, ZERO, 1
9D000690  AFA60010   SW A2, 16(SP)
9D000694  00603021   ADDU A2, V1, ZERO
9D000698  00403821   ADDU A3, V0, ZERO
9D00069C  0F400280   JAL SendFrame
9D0006A0  00000000   NOP
176:                     
177:                     DSP_CR200bits.ENVREF2=1;         //enable V ref1 bit for CH1;
9D0006A4  978280F4   LHU V0, -32524(GP)
9D0006A8  24030001   ADDIU V1, ZERO, 1
9D0006AC  7C622944   INS V0, V1, 5, 1
9D0006B0  A78280F4   SH V0, -32524(GP)
178:                     DSP_CR200bits.TC2=0x02;          //set temperature compensation for CH1;  Vref2=1.18v default
9D0006B4  978280F4   LHU V0, -32524(GP)
9D0006B8  24030002   ADDIU V1, ZERO, 2
9D0006BC  7C624184   INS V0, V1, 6, 3
9D0006C0  A78280F4   SH V0, -32524(GP)
179:                     
180:                     readAdd=0x00;
9D0006C4  A38080FC   SB ZERO, -32516(GP)
181:                     writeAdd=0x02; 
9D0006C8  24020002   ADDIU V0, ZERO, 2
9D0006CC  A38280C8   SB V0, -32568(GP)
182:                     dataLSB=DSP_CR200bits.LSB;
9D0006D0  938280F4   LBU V0, -32524(GP)
9D0006D4  7C021420   SEB V0, V0
9D0006D8  A38280F0   SB V0, -32528(GP)
183:                     dataMSB=DSP_CR200bits.MSB;
9D0006DC  938280F5   LBU V0, -32523(GP)
9D0006E0  7C021420   SEB V0, V0
9D0006E4  A3828110   SB V0, -32496(GP)
184:                     SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);    //write to  CR2 register
9D0006E8  838280FC   LB V0, -32516(GP)
9D0006EC  00402021   ADDU A0, V0, ZERO
9D0006F0  838280C8   LB V0, -32568(GP)
9D0006F4  00402821   ADDU A1, V0, ZERO
9D0006F8  838280F0   LB V0, -32528(GP)
9D0006FC  00401821   ADDU V1, V0, ZERO
9D000700  83828110   LB V0, -32496(GP)
9D000704  24060001   ADDIU A2, ZERO, 1
9D000708  AFA60010   SW A2, 16(SP)
9D00070C  00603021   ADDU A2, V1, ZERO
9D000710  00403821   ADDU A3, V0, ZERO
9D000714  0F400280   JAL SendFrame
9D000718  00000000   NOP
185:                     /***********************************/
186:                    
187:                    DSP_CR101bits.BHPFV1=0;          //HPF enable voltage;DC cancellation
9D00071C  9782812C   LHU V0, -32468(GP)
9D000720  7C0218C4   INS V0, ZERO, 3, 1
9D000724  A782812C   SH V0, -32468(GP)
188:                    DSP_CR101bits.BHPFC1=0;          //HPF enable current;DC cancellation
9D000728  9782812C   LHU V0, -32468(GP)
9D00072C  7C022104   INS V0, ZERO, 4, 1
9D000730  A782812C   SH V0, -32468(GP)
189:                    DSP_CR101bits.BLPFV1=1;          //LPF wideband voltage;set up fundamental mode
9D000734  9782812C   LHU V0, -32468(GP)
9D000738  24030001   ADDIU V1, ZERO, 1
9D00073C  7C623184   INS V0, V1, 6, 1
9D000740  A782812C   SH V0, -32468(GP)
190:                    DSP_CR101bits.BLPFC1=1;          //LPF wideband current;set up fundamental mode
9D000744  9782812C   LHU V0, -32468(GP)
9D000748  24030001   ADDIU V1, ZERO, 1
9D00074C  7C6239C4   INS V0, V1, 7, 1
9D000750  A782812C   SH V0, -32468(GP)
191:                   
192:                    readAdd=0x01;
9D000754  24020001   ADDIU V0, ZERO, 1
9D000758  A38280FC   SB V0, -32516(GP)
193:                    writeAdd=0x01; 
9D00075C  24020001   ADDIU V0, ZERO, 1
9D000760  A38280C8   SB V0, -32568(GP)
194:                    dataLSB=DSP_CR101bits.LSB;
9D000764  9382812C   LBU V0, -32468(GP)
9D000768  7C021420   SEB V0, V0
9D00076C  A38280F0   SB V0, -32528(GP)
195:                    dataMSB=DSP_CR101bits.MSB;
9D000770  9382812D   LBU V0, -32467(GP)
9D000774  7C021420   SEB V0, V0
9D000778  A3828110   SB V0, -32496(GP)
196:                    SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);    //write to  CR1 register
9D00077C  838280FC   LB V0, -32516(GP)
9D000780  00402021   ADDU A0, V0, ZERO
9D000784  838280C8   LB V0, -32568(GP)
9D000788  00402821   ADDU A1, V0, ZERO
9D00078C  838280F0   LB V0, -32528(GP)
9D000790  00401821   ADDU V1, V0, ZERO
9D000794  83828110   LB V0, -32496(GP)
9D000798  24060001   ADDIU A2, ZERO, 1
9D00079C  AFA60010   SW A2, 16(SP)
9D0007A0  00603021   ADDU A2, V1, ZERO
9D0007A4  00403821   ADDU A3, V0, ZERO
9D0007A8  0F400280   JAL SendFrame
9D0007AC  00000000   NOP
197:                    
198:                    DSP_CR201bits.BHPFV2=0;          //HPF enable voltage;DC cancellation
9D0007B0  978280E8   LHU V0, -32536(GP)
9D0007B4  7C0218C4   INS V0, ZERO, 3, 1
9D0007B8  A78280E8   SH V0, -32536(GP)
199:                    DSP_CR201bits.BHPFC2=0;          //HPF enable current;DC cancellation
9D0007BC  978280E8   LHU V0, -32536(GP)
9D0007C0  7C022104   INS V0, ZERO, 4, 1
9D0007C4  A78280E8   SH V0, -32536(GP)
200:                    DSP_CR201bits.BLPFV2=1;          //LPF bypassed -  wideband voltage;set up fundamental mode
9D0007C8  978280E8   LHU V0, -32536(GP)
9D0007CC  24030001   ADDIU V1, ZERO, 1
9D0007D0  7C623184   INS V0, V1, 6, 1
9D0007D4  A78280E8   SH V0, -32536(GP)
201:                    DSP_CR201bits.BLPFC2=1;          //LPF bypassed -  wideband current;set up fundamental mode
9D0007D8  978280E8   LHU V0, -32536(GP)
9D0007DC  24030001   ADDIU V1, ZERO, 1
9D0007E0  7C6239C4   INS V0, V1, 7, 1
9D0007E4  A78280E8   SH V0, -32536(GP)
202:                    readAdd=0x03;
9D0007E8  24020003   ADDIU V0, ZERO, 3
9D0007EC  A38280FC   SB V0, -32516(GP)
203:                    writeAdd=0x03;
9D0007F0  24020003   ADDIU V0, ZERO, 3
9D0007F4  A38280C8   SB V0, -32568(GP)
204:                    dataLSB=DSP_CR201bits.LSB;
9D0007F8  938280E8   LBU V0, -32536(GP)
9D0007FC  7C021420   SEB V0, V0
9D000800  A38280F0   SB V0, -32528(GP)
205:                    dataMSB=DSP_CR201bits.MSB;
9D000804  938280E9   LBU V0, -32535(GP)
9D000808  7C021420   SEB V0, V0
9D00080C  A3828110   SB V0, -32496(GP)
206:                    SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);
9D000810  838280FC   LB V0, -32516(GP)
9D000814  00402021   ADDU A0, V0, ZERO
9D000818  838280C8   LB V0, -32568(GP)
9D00081C  00402821   ADDU A1, V0, ZERO
9D000820  838280F0   LB V0, -32528(GP)
9D000824  00401821   ADDU V1, V0, ZERO
9D000828  83828110   LB V0, -32496(GP)
9D00082C  24060001   ADDIU A2, ZERO, 1
9D000830  AFA60010   SW A2, 16(SP)
9D000834  00603021   ADDU A2, V1, ZERO
9D000838  00403821   ADDU A3, V0, ZERO
9D00083C  0F400280   JAL SendFrame
9D000840  00000000   NOP
207:                    
208:                    //set GAIN1, in DFE_CR1 register
209:                    
210:                     DFE_CR101bits.GAIN1=0x02;           //set current gain for Chn1
9D000844  978280DC   LHU V0, -32548(GP)
9D000848  24030002   ADDIU V1, ZERO, 2
9D00084C  7C625A84   INS V0, V1, 10, 2
9D000850  A78280DC   SH V0, -32548(GP)
211:                     readAdd=0x00;
9D000854  A38080FC   SB ZERO, -32516(GP)
212:                     writeAdd=0x19;
9D000858  24020019   ADDIU V0, ZERO, 25
9D00085C  A38280C8   SB V0, -32568(GP)
213:                     dataLSB=DFE_CR101bits.LSB;
9D000860  938280DC   LBU V0, -32548(GP)
9D000864  7C021420   SEB V0, V0
9D000868  A38280F0   SB V0, -32528(GP)
214:                     dataMSB=DFE_CR101bits.MSB;
9D00086C  938280DD   LBU V0, -32547(GP)
9D000870  7C021420   SEB V0, V0
9D000874  A3828110   SB V0, -32496(GP)
215:                     SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);
9D000878  838280FC   LB V0, -32516(GP)
9D00087C  00402021   ADDU A0, V0, ZERO
9D000880  838280C8   LB V0, -32568(GP)
9D000884  00402821   ADDU A1, V0, ZERO
9D000888  838280F0   LB V0, -32528(GP)
9D00088C  00401821   ADDU V1, V0, ZERO
9D000890  83828110   LB V0, -32496(GP)
9D000894  24060001   ADDIU A2, ZERO, 1
9D000898  AFA60010   SW A2, 16(SP)
9D00089C  00603021   ADDU A2, V1, ZERO
9D0008A0  00403821   ADDU A3, V0, ZERO
9D0008A4  0F400280   JAL SendFrame
9D0008A8  00000000   NOP
216:                     
217:                     //set GAIN2 in DFE_CR2 register
218:                     DFE_CR201bits.GAIN1=0x02;           //set current gain for Chn2
9D0008AC  978280CC   LHU V0, -32564(GP)
9D0008B0  24030002   ADDIU V1, ZERO, 2
9D0008B4  7C625A84   INS V0, V1, 10, 2
9D0008B8  A78280CC   SH V0, -32564(GP)
219:                     readAdd=0x00;
9D0008BC  A38080FC   SB ZERO, -32516(GP)
220:                     writeAdd=0x1B;
9D0008C0  2402001B   ADDIU V0, ZERO, 27
9D0008C4  A38280C8   SB V0, -32568(GP)
221:                     dataLSB=DFE_CR201bits.LSB;
9D0008C8  938280CC   LBU V0, -32564(GP)
9D0008CC  7C021420   SEB V0, V0
9D0008D0  A38280F0   SB V0, -32528(GP)
222:                     dataMSB=DFE_CR201bits.MSB;
9D0008D4  938280CD   LBU V0, -32563(GP)
9D0008D8  7C021420   SEB V0, V0
9D0008DC  A3828110   SB V0, -32496(GP)
223:                     SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);
9D0008E0  838280FC   LB V0, -32516(GP)
9D0008E4  00402021   ADDU A0, V0, ZERO
9D0008E8  838280C8   LB V0, -32568(GP)
9D0008EC  00402821   ADDU A1, V0, ZERO
9D0008F0  838280F0   LB V0, -32528(GP)
9D0008F4  00401821   ADDU V1, V0, ZERO
9D0008F8  83828110   LB V0, -32496(GP)
9D0008FC  24060001   ADDIU A2, ZERO, 1
9D000900  AFA60010   SW A2, 16(SP)
9D000904  00603021   ADDU A2, V1, ZERO
9D000908  00403821   ADDU A3, V0, ZERO
9D00090C  0F400280   JAL SendFrame
9D000910  00000000   NOP
224:                   
225:                    DSP_CR301bits.SWAuto_Latch=1;        // Automatic measurement register latch at 7.8125 kHz
9D000914  97828118   LHU V0, -32488(GP)
9D000918  24030001   ADDIU V1, ZERO, 1
9D00091C  7C6239C4   INS V0, V1, 7, 1
9D000920  A7828118   SH V0, -32488(GP)
226:                    readAdd=0x05;
9D000924  24020005   ADDIU V0, ZERO, 5
9D000928  A38280FC   SB V0, -32516(GP)
227:                    writeAdd=0x05;
9D00092C  24020005   ADDIU V0, ZERO, 5
9D000930  A38280C8   SB V0, -32568(GP)
228:                    dataMSB=DSP_CR301bits.MSB;
9D000934  93828119   LBU V0, -32487(GP)
9D000938  7C021420   SEB V0, V0
9D00093C  A3828110   SB V0, -32496(GP)
229:                    dataLSB=DSP_CR301bits.LSB;
9D000940  93828118   LBU V0, -32488(GP)
9D000944  7C021420   SEB V0, V0
9D000948  A38280F0   SB V0, -32528(GP)
230:                    SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);
9D00094C  838280FC   LB V0, -32516(GP)
9D000950  00402021   ADDU A0, V0, ZERO
9D000954  838280C8   LB V0, -32568(GP)
9D000958  00402821   ADDU A1, V0, ZERO
9D00095C  838280F0   LB V0, -32528(GP)
9D000960  00401821   ADDU V1, V0, ZERO
9D000964  83828110   LB V0, -32496(GP)
9D000968  24060001   ADDIU A2, ZERO, 1
9D00096C  AFA60010   SW A2, 16(SP)
9D000970  00603021   ADDU A2, V1, ZERO
9D000974  00403821   ADDU A3, V0, ZERO
9D000978  0F400280   JAL SendFrame
9D00097C  00000000   NOP
231:                    
232:                    US1_REG100bits.CRC_EN=0;         //disable CRC polynomial
9D000980  978280F8   LHU V0, -32520(GP)
9D000984  7C027384   INS V0, ZERO, 14, 1
9D000988  A78280F8   SH V0, -32520(GP)
233:                    readAdd=0x24;
9D00098C  24020024   ADDIU V0, ZERO, 36
9D000990  A38280FC   SB V0, -32516(GP)
234:                    writeAdd=0x24;
9D000994  24020024   ADDIU V0, ZERO, 36
9D000998  A38280C8   SB V0, -32568(GP)
235:                    dataMSB=US1_REG100bits.MSB;
9D00099C  938280F9   LBU V0, -32519(GP)
9D0009A0  7C021420   SEB V0, V0
9D0009A4  A3828110   SB V0, -32496(GP)
236:                    dataLSB=US1_REG100bits.LSB;
9D0009A8  938280F8   LBU V0, -32520(GP)
9D0009AC  7C021420   SEB V0, V0
9D0009B0  A38280F0   SB V0, -32528(GP)
237:                    SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);
9D0009B4  838280FC   LB V0, -32516(GP)
9D0009B8  00402021   ADDU A0, V0, ZERO
9D0009BC  838280C8   LB V0, -32568(GP)
9D0009C0  00402821   ADDU A1, V0, ZERO
9D0009C4  838280F0   LB V0, -32528(GP)
9D0009C8  00401821   ADDU V1, V0, ZERO
9D0009CC  83828110   LB V0, -32496(GP)
9D0009D0  24060001   ADDIU A2, ZERO, 1
9D0009D4  AFA60010   SW A2, 16(SP)
9D0009D8  00603021   ADDU A2, V1, ZERO
9D0009DC  00403821   ADDU A3, V0, ZERO
9D0009E0  0F400280   JAL SendFrame
9D0009E4  00000000   NOP
238:                  }
9D0009E8  03C0E821   ADDU SP, S8, ZERO
9D0009EC  8FBF001C   LW RA, 28(SP)
9D0009F0  8FBE0018   LW S8, 24(SP)
9D0009F4  27BD0020   ADDIU SP, SP, 32
9D0009F8  03E00008   JR RA
9D0009FC  00000000   NOP
239:                 
240:                 void SendFrame(char readAdd,char writeAdd, char dataLSB,char dataMSB,short int csNum)
241:                 {
9D000A00  27BDFFE0   ADDIU SP, SP, -32
9D000A04  AFBF001C   SW RA, 28(SP)
9D000A08  AFBE0018   SW S8, 24(SP)
9D000A0C  03A0F021   ADDU S8, SP, ZERO
9D000A10  00804021   ADDU T0, A0, ZERO
9D000A14  00C02021   ADDU A0, A2, ZERO
9D000A18  00E01821   ADDU V1, A3, ZERO
9D000A1C  8FC20030   LW V0, 48(S8)
9D000A20  A3C80020   SB T0, 32(S8)
9D000A24  A3C50024   SB A1, 36(S8)
9D000A28  A3C40028   SB A0, 40(S8)
9D000A2C  A3C3002C   SB V1, 44(S8)
9D000A30  A7C20010   SH V0, 16(S8)
242:                     sendBuff[0]=readAdd;
9D000A34  93C20020   LBU V0, 32(S8)
9D000A38  A3828114   SB V0, -32492(GP)
243:                     sendBuff[1]=writeAdd;
9D000A3C  93C20024   LBU V0, 36(S8)
9D000A40  A3828115   SB V0, -32491(GP)
244:                     sendBuff[2]=dataLSB;
9D000A44  93C20028   LBU V0, 40(S8)
9D000A48  A3828116   SB V0, -32490(GP)
245:                     sendBuff[3]=dataMSB;
9D000A4C  93C2002C   LBU V0, 44(S8)
9D000A50  A3828117   SB V0, -32489(GP)
246:                     
247:                       
248:                         pSrc=sendBuff; 
9D000A54  27828114   ADDIU V0, GP, -32492
9D000A58  AF8280EC   SW V0, -32532(GP)
249:                          SetCSpin(csNum);                              //set CS-x active
9D000A5C  87C20010   LH V0, 16(S8)
9D000A60  00402021   ADDU A0, V0, ZERO
9D000A64  0F400318   JAL SetCSpin
9D000A68  00000000   NOP
250:                         for(ix=0;ix<4;ix++)
9D000A6C  AF80810C   SW ZERO, -32500(GP)
9D000A70  0B4002AE   J 0x9D000AB8
9D000A74  00000000   NOP
9D000AAC  8F82810C   LW V0, -32500(GP)
9D000AB0  24420001   ADDIU V0, V0, 1
9D000AB4  AF82810C   SW V0, -32500(GP)
9D000AB8  8F82810C   LW V0, -32500(GP)
9D000ABC  28420004   SLTI V0, V0, 4
9D000AC0  1440FFED   BNE V0, ZERO, 0x9D000A78
9D000AC4  00000000   NOP
251:                         {
252:                            while(SPI2STATbits.SPITBF==1){} 
9D000A78  00000000   NOP
9D000A7C  3C02BF80   LUI V0, -16512
9D000A80  8C425A10   LW V0, 23056(V0)
9D000A84  30420002   ANDI V0, V0, 2
9D000A88  1440FFFC   BNE V0, ZERO, 0x9D000A7C
9D000A8C  00000000   NOP
253:                              SPI2BUF=*pSrc++;
9D000A90  8F8280EC   LW V0, -32532(GP)
9D000A94  24430001   ADDIU V1, V0, 1
9D000A98  AF8380EC   SW V1, -32532(GP)
9D000A9C  80420000   LB V0, 0(V0)
9D000AA0  00401821   ADDU V1, V0, ZERO
9D000AA4  3C02BF80   LUI V0, -16512
9D000AA8  AC435A20   SW V1, 23072(V0)
254:                            
255:                              
256:                         }
257:                           SetCSpin(6);                    //CS_x pins non-active
9D000AC8  24040006   ADDIU A0, ZERO, 6
9D000ACC  0F400318   JAL SetCSpin
9D000AD0  00000000   NOP
258:                         
259:                 }
9D000AD4  03C0E821   ADDU SP, S8, ZERO
9D000AD8  8FBF001C   LW RA, 28(SP)
9D000ADC  8FBE0018   LW S8, 24(SP)
9D000AE0  27BD0020   ADDIU SP, SP, 32
9D000AE4  03E00008   JR RA
9D000AE8  00000000   NOP
260:                 void Delay(void)
261:                 {
9D000AEC  27BDFFF8   ADDIU SP, SP, -8
9D000AF0  AFBE0004   SW S8, 4(SP)
9D000AF4  03A0F021   ADDU S8, SP, ZERO
262:                     delayValue=80*100;
9D000AF8  24021F40   ADDIU V0, ZERO, 8000
9D000AFC  AF828120   SW V0, -32480(GP)
263:                     while(delayValue--);
9D000B00  00000000   NOP
9D000B04  8F828120   LW V0, -32480(GP)
9D000B08  2443FFFF   ADDIU V1, V0, -1
9D000B0C  AF838120   SW V1, -32480(GP)
9D000B10  1440FFFC   BNE V0, ZERO, 0x9D000B04
9D000B14  00000000   NOP
264:                     
265:                 }
9D000B18  03C0E821   ADDU SP, S8, ZERO
9D000B1C  8FBE0004   LW S8, 4(SP)
9D000B20  27BD0008   ADDIU SP, SP, 8
9D000B24  03E00008   JR RA
9D000B28  00000000   NOP
266:                 void ReadFrame(unsigned int address, unsigned int* buffer, short int csNum)
267:                 {
9D000B2C  27BDFFE0   ADDIU SP, SP, -32
9D000B30  AFBF001C   SW RA, 28(SP)
9D000B34  AFBE0018   SW S8, 24(SP)
9D000B38  03A0F021   ADDU S8, SP, ZERO
9D000B3C  AFC40020   SW A0, 32(S8)
9D000B40  AFC50024   SW A1, 36(S8)
9D000B44  00C01021   ADDU V0, A2, ZERO
9D000B48  A7C20028   SH V0, 40(S8)
268:                     readAdd=address;                                //read register from register map
9D000B4C  8FC20020   LW V0, 32(S8)
9D000B50  7C021420   SEB V0, V0
9D000B54  A38280FC   SB V0, -32516(GP)
269:                     writeAdd=0xff;                                  //dummy write address
9D000B58  2402FFFF   ADDIU V0, ZERO, -1
9D000B5C  A38280C8   SB V0, -32568(GP)
270:                     dataLSB=0xff;                                   //dummy byte
9D000B60  2402FFFF   ADDIU V0, ZERO, -1
9D000B64  A38280F0   SB V0, -32528(GP)
271:                     dataMSB=0xff;                                   //dummy byte
9D000B68  2402FFFF   ADDIU V0, ZERO, -1
9D000B6C  A3828110   SB V0, -32496(GP)
272:                     pRcv=receiveBuff;
9D000B70  27828104   ADDIU V0, GP, -32508
9D000B74  AF8280E0   SW V0, -32544(GP)
273:                     
274:                     SendFrame(readAdd,writeAdd,dataLSB,dataMSB,1);
9D000B78  838280FC   LB V0, -32516(GP)
9D000B7C  00402021   ADDU A0, V0, ZERO
9D000B80  838280C8   LB V0, -32568(GP)
9D000B84  00402821   ADDU A1, V0, ZERO
9D000B88  838280F0   LB V0, -32528(GP)
9D000B8C  00401821   ADDU V1, V0, ZERO
9D000B90  83828110   LB V0, -32496(GP)
9D000B94  24060001   ADDIU A2, ZERO, 1
9D000B98  AFA60010   SW A2, 16(SP)
9D000B9C  00603021   ADDU A2, V1, ZERO
9D000BA0  00403821   ADDU A3, V0, ZERO
9D000BA4  0F400280   JAL SendFrame
9D000BA8  00000000   NOP
275:                     
276:                      SetCSpin(csNum);                              //set CS-x active
9D000BAC  87C20028   LH V0, 40(S8)
9D000BB0  00402021   ADDU A0, V0, ZERO
9D000BB4  0F400318   JAL SetCSpin
9D000BB8  00000000   NOP
277:                      for(i=0;i<4;i++)
9D000BBC  AF8080D0   SW ZERO, -32560(GP)
9D000BC0  0B400308   J 0x9D000C20
9D000BC4  00000000   NOP
9D000C14  8F8280D0   LW V0, -32560(GP)
9D000C18  24420001   ADDIU V0, V0, 1
9D000C1C  AF8280D0   SW V0, -32560(GP)
9D000C20  8F8280D0   LW V0, -32560(GP)
9D000C24  28420004   SLTI V0, V0, 4
9D000C28  1440FFE7   BNE V0, ZERO, 0x9D000BC8
9D000C2C  00000000   NOP
278:                          {
279:                            // SpiChnGetS(2,buffer,4);                // store in buffer 4 bytes from selected 
280:                          SetCSpin(csNum); 
9D000BC8  87C20028   LH V0, 40(S8)
9D000BCC  00402021   ADDU A0, V0, ZERO
9D000BD0  0F400318   JAL SetCSpin
9D000BD4  00000000   NOP
281:                          while(SPI2STATbits.SPIRBF==1){}
9D000BD8  00000000   NOP
9D000BDC  3C02BF80   LUI V0, -16512
9D000BE0  8C425A10   LW V0, 23056(V0)
9D000BE4  30420001   ANDI V0, V0, 1
9D000BE8  1440FFFC   BNE V0, ZERO, 0x9D000BDC
9D000BEC  00000000   NOP
282:                          *pRcv++=SPI2BUF;
9D000BF0  8F8280E0   LW V0, -32544(GP)
9D000BF4  24430001   ADDIU V1, V0, 1
9D000BF8  AF8380E0   SW V1, -32544(GP)
9D000BFC  3C03BF80   LUI V1, -16512
9D000C00  8C635A20   LW V1, 23072(V1)
9D000C04  7C031C20   SEB V1, V1
9D000C08  A0430000   SB V1, 0(V0)
283:                         
284:                             Delay();
9D000C0C  0F4002BB   JAL Delay
9D000C10  00000000   NOP
285:                          }  
286:                      SetCSpin(6);
9D000C30  24040006   ADDIU A0, ZERO, 6
9D000C34  0F400318   JAL SetCSpin
9D000C38  00000000   NOP
287:                     
288:                      SetCSpin(6);
9D000C3C  24040006   ADDIU A0, ZERO, 6
9D000C40  0F400318   JAL SetCSpin
9D000C44  00000000   NOP
289:                 }
9D000C48  03C0E821   ADDU SP, S8, ZERO
9D000C4C  8FBF001C   LW RA, 28(SP)
9D000C50  8FBE0018   LW S8, 24(SP)
9D000C54  27BD0020   ADDIU SP, SP, 32
9D000C58  03E00008   JR RA
9D000C5C  00000000   NOP
290:                 void SetCSpin(int csNum)
291:                 {
9D000C60  27BDFFF8   ADDIU SP, SP, -8
9D000C64  AFBE0004   SW S8, 4(SP)
9D000C68  03A0F021   ADDU S8, SP, ZERO
9D000C6C  AFC40008   SW A0, 8(S8)
292:                     switch (csNum)
9D000C70  8FC20008   LW V0, 8(S8)
9D000C74  2C420007   SLTIU V0, V0, 7
9D000C78  10400037   BEQ V0, ZERO, 0x9D000D58
9D000C7C  00000000   NOP
9D000C80  8FC20008   LW V0, 8(S8)
9D000C84  00021880   SLL V1, V0, 2
9D000C88  3C029D00   LUI V0, -25344
9D000C8C  24420CA0   ADDIU V0, V0, 3232
9D000C90  00621021   ADDU V0, V1, V0
9D000C94  8C420000   LW V0, 0(V0)
9D000C98  00400008   JR V0
9D000C9C  00000000   NOP
293:                     {
294:                         case 1:
295:                             PORTGbits.RG9=0;                // activate CS_1
9D000CBC  3C03BF88   LUI V1, -16504
9D000CC0  94626190   LHU V0, 24976(V1)
9D000CC4  7C024A44   INS V0, ZERO, 9, 1
9D000CC8  A4626190   SH V0, 24976(V1)
296:                             break;
9D000CCC  0B400356   J 0x9D000D58
9D000CD0  00000000   NOP
297:                         case 2:
298:                             PORTBbits.RB5=0;                // activate CS_2
9D000CD4  3C03BF88   LUI V1, -16504
9D000CD8  94626050   LHU V0, 24656(V1)
9D000CDC  7C022944   INS V0, ZERO, 5, 1
9D000CE0  A4626050   SH V0, 24656(V1)
299:                             break;   
9D000CE4  0B400356   J 0x9D000D58
9D000CE8  00000000   NOP
300:                         case 3:
301:                             PORTBbits.RB4=0;                // activate CS_3
9D000CEC  3C03BF88   LUI V1, -16504
9D000CF0  94626050   LHU V0, 24656(V1)
9D000CF4  7C022104   INS V0, ZERO, 4, 1
9D000CF8  A4626050   SH V0, 24656(V1)
302:                             break;
9D000CFC  0B400356   J 0x9D000D58
9D000D00  00000000   NOP
303:                         case 4:
304:                             PORTBbits.RB2=0;                // activate CS_4
9D000D04  3C03BF88   LUI V1, -16504
9D000D08  94626050   LHU V0, 24656(V1)
9D000D0C  7C021084   INS V0, ZERO, 2, 1
9D000D10  A4626050   SH V0, 24656(V1)
305:                             break;
9D000D14  0B400356   J 0x9D000D58
9D000D18  00000000   NOP
306:                         case 5:
307:                             PORTBbits.RB3=0;                // activate CS_5
9D000D1C  3C03BF88   LUI V1, -16504
9D000D20  94626050   LHU V0, 24656(V1)
9D000D24  7C0218C4   INS V0, ZERO, 3, 1
9D000D28  A4626050   SH V0, 24656(V1)
308:                             break;
9D000D2C  0B400356   J 0x9D000D58
9D000D30  00000000   NOP
309:                         case 6:
310:                             PORTGbits.RG9=1;
9D000D34  3C03BF88   LUI V1, -16504
9D000D38  94626190   LHU V0, 24976(V1)
9D000D3C  24040001   ADDIU A0, ZERO, 1
9D000D40  7C824A44   INS V0, A0, 9, 1
9D000D44  A4626190   SH V0, 24976(V1)
311:                             PORTBINV=0x003c;                // all CS_x pins inactive
9D000D48  3C02BF88   LUI V0, -16504
9D000D4C  2403003C   ADDIU V1, ZERO, 60
9D000D50  AC43605C   SW V1, 24668(V0)
312:                             break;
9D000D54  00000000   NOP
313:                     }
314:                 }
9D000D58  03C0E821   ADDU SP, S8, ZERO
9D000D5C  8FBE0004   LW S8, 4(SP)
9D000D60  27BD0008   ADDIU SP, SP, 8
9D000D64  03E00008   JR RA
9D000D68  00000000   NOP
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the “Company”) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Company’s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
9D000024  8FC20014   LW V0, 20(S8)
9D000028  AFC20018   SW V0, 24(S8)
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D00002C  8FC30014   LW V1, 20(S8)
9D000030  3C0204C4   LUI V0, 1220
9D000034  3442B401   ORI V0, V0, -19455
9D000038  0062102B   SLTU V0, V1, V0
9D00003C  14400008   BNE V0, ZERO, 0x9D000060
9D000040  00000000   NOP
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
9D000044  3C020008   LUI V0, 8
9D000048  AFC2001C   SW V0, 28(S8)
131:                         pb_clock >>= 1;
9D00004C  8FC20018   LW V0, 24(S8)
9D000050  00021042   SRL V0, V0, 1
9D000054  AFC20018   SW V0, 24(S8)
9D000058  0B400019   J 0x9D000064
9D00005C  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
9D000060  AFC0001C   SW ZERO, 28(S8)
9D000064  8FC2001C   LW V0, 28(S8)
9D000068  AFC20020   SW V0, 32(S8)
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
9D0001AC  8FC20018   LW V0, 24(S8)
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
9D0001B0  AFC20038   SW V0, 56(S8)
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
9D0001B4  AFC0003C   SW ZERO, 60(S8)
9D0001B8  0B400078   J 0x9D0001E0
9D0001BC  00000000   NOP
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
9D0001E0  8FC30010   LW V1, 16(S8)
9D0001E4  3C0201C9   LUI V0, 457
9D0001E8  3442C381   ORI V0, V0, -15487
9D0001EC  0062102B   SLTU V0, V1, V0
9D0001F0  1040FFF3   BEQ V0, ZERO, 0x9D0001C0
9D0001F4  00000000   NOP
240:                     {
241:                         wait_states++;
9D0001C0  8FC2003C   LW V0, 60(S8)
9D0001C4  24420001   ADDIU V0, V0, 1
9D0001C8  AFC2003C   SW V0, 60(S8)
242:                         sys_clock -= FLASH_SPEED_HZ;
9D0001CC  8FC30010   LW V1, 16(S8)
9D0001D0  3C02FE36   LUI V0, -458
9D0001D4  34423C80   ORI V0, V0, 15488
9D0001D8  00621021   ADDU V0, V1, V0
9D0001DC  AFC20010   SW V0, 16(S8)
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
9D0001F8  0F400760   JAL INTDisableInterrupts
9D0001FC  00000000   NOP
9D000200  AFC20040   SW V0, 64(S8)
246:                     mCheConfigure(wait_states);
9D000204  3C02BF88   LUI V0, -16504
9D000208  8FC3003C   LW V1, 60(S8)
9D00020C  AC434000   SW V1, 16384(V0)
247:                     INTRestoreInterrupts(int_status);
9D000210  8FC40040   LW A0, 64(S8)
9D000214  0F40073F   JAL INTRestoreInterrupts
9D000218  00000000   NOP
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
355:                 
356:                     mBMXDisableDRMWaitState();
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
381:                 
382:                     INTRestoreInterrupts(int_status);
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/osc.h  ----------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the “Company”) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Company’s customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  /*
47:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
48:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
49:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
50:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
51:                  */
52:                  #ifndef _SUPPRESS_PLIB_WARNING
53:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
54:                  #endif
55:                  
56:                  
57:                  #define _OSC_
58:                  
59:                  /*********************************************************************
60:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
61:                   *
62:                   * Description:     Sets Osc options and clock source
63:                   *
64:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
65:                   *
66:                   * Inputs:          Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
67:                   *
68:                   * Output:          None
69:                   *
70:                   * Example:         OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
71:                   *
72:                   * Note:            Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
73:                   *                  source and then switches to the new clock source
74:                   *
75:                   *                  Unused parameters are set to zero/default values.
76:                   ********************************************************************/
77:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
78:                  
79:                      /******************************************************************************
80:                       * Available options for source parameter
81:                       *****************************************************************************/
82:                          // CPU Oscillator modes - values are mutually exclusive
83:                          #define OSC_FRC_DIV     (7 << _OSCCON_NOSC_POSITION)
84:                          #define OSC_FRC_DIV16   (6 << _OSCCON_NOSC_POSITION)
85:                          #define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
86:                          #define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
87:                          #define OSC_POSC_PLL    (3 << _OSCCON_NOSC_POSITION)
88:                          #define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
89:                          #define OSC_FRC_PLL     (1 << _OSCCON_NOSC_POSITION)
90:                          #define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
91:                  
92:                      /******************************************************************************
93:                       * Available options for mult parameter
94:                       *****************************************************************************/
95:                          // CPU PLL multiplier values - values are mutually exclusive
96:                          #define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
97:                          #define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
98:                          #define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
99:                          #define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
100:                         #define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
101:                         #define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
102:                         #define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
103:                         #define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
104:                 
105:                     /******************************************************************************
106:                      * Available options for post parameter
107:                      *****************************************************************************/
108:                         // CPU PLL output divisor values - values are mutuallye exclusive
109:                         #define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
110:                         #define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
111:                         #define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
112:                         #define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
113:                         #define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
114:                         #define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
115:                         #define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
116:                         #define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
117:                 
118:                     /******************************************************************************
119:                      * Available options for div parameter
120:                      *****************************************************************************/
121:                         // CPU FRC output divisor values - values are mutually exclusive
122:                         #define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
123:                         #define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
124:                         #define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
125:                         #define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
126:                         #define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
127:                         #define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
128:                         #define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
129:                         #define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
130:                     /***********************************
131:                      * End parameter values
132:                      ************************************/
133:                 
134:                 #if defined(__32MX120F064H__) || \
135:                     defined(__32MX130F128H__) || \
136:                     defined(__32MX130F128L__) || \
137:                     defined(__32MX150F256H__) || \
138:                     defined(__32MX150F256L__) || \
139:                     defined(__32MX170F512H__) || \
140:                     defined(__32MX170F512L__) || \
141:                     defined(__32MX230F128H__) || \
142:                     defined(__32MX230F128L__) || \
143:                     defined(__32MX250F256H__) || \
144:                     defined(__32MX250F256L__) || \
145:                     defined(__32MX270F512H__) || \
146:                     defined(__32MX270F512L__) || \
147:                     defined(__32MX530F128H__) || \
148:                     defined(__32MX530F128L__) || \
149:                     defined(__32MX550F256H__) || \
150:                     defined(__32MX550F256L__) || \
151:                     defined(__32MX570F512H__) || \
152:                     defined(__32MX570F512L__)
153:                   #define NEED_OSCREFCONFIG_FLAGS
154:                 #elif (__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)
155:                   #define NEED_OSCREFCONFIG_FLAGS
156:                 #elif (__PIC32_FEATURE_SET__ == 330) || \
157:                       (__PIC32_FEATURE_SET__ == 350) || \
158:                       (__PIC32_FEATURE_SET__ == 370) || \
159:                       (__PIC32_FEATURE_SET__ == 430) || \
160:                       (__PIC32_FEATURE_SET__ == 450) || \
161:                       (__PIC32_FEATURE_SET__ == 470)
162:                   #define NEED_OSCREFCONFIG_FLAGS
163:                 #else
164:                   #undef  NEED_OSCREFCONFIG_FLAGS
165:                 #endif
166:                 
167:                 #if defined( NEED_OSCREFCONFIG_FLAGS )
168:                     // Reference Oscillator Source Select bits - values are mutually exclusive
169:                     #define OSC_REFOCON_REFCLKI     (7 << _REFOCON_ROSEL_POSITION )
170:                     #define OSC_REFOCON_SYSPLL      (7 << _REFOCON_ROSEL_POSITION )
171:                     #define OSC_REFOCON_USBPLL      (6 << _REFOCON_ROSEL_POSITION )
172:                     #define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
173:                     #define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
174:                     #define OSC_REFOCON_FRC         (3 << _REFOCON_ROSEL_POSITION )
175:                     #define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
176:                     #define OSC_REFOCON_PBCLK       (1 << _REFOCON_ROSEL_POSITION )
177:                     #define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
178:                 
179:                     typedef enum
180:                     {
181:                             OSC_REFOCON_RLSPEN      =(1 << _REFOCON_RSLP_POSITION ) ,
182:                             OSC_REFOCON_OE          =(1 << _REFOCON_OE_POSITION ),
183:                             OSC_REFOCON_SIDLEN      =(1 << _REFOCON_SIDL_POSITION ),
184:                             OSC_REFOCON_ON          =(1 << _REFOCON_ON_POSITION )
185:                     } OSCREFConfigFlags;
186:                 
187:                     void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
188:                 
189:                 
190:                     #define mOSCREFOTRIMSet(trim)       (REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
191:                 
192:                 #endif//defined( NEED_OSCREFCONFIG_FLAGS )
193:                 
194:                 #undef  NEED_OSCREFCONFIG_FLAGS
195:                 
196:                 
197:                 /*********************************************************************
198:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
199:                  *
200:                  * Description: Configures peripheral bus divisor
201:                  *
202:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
203:                  *
204:                  * Inputs:    oscPbDiv - desired PB divider
205:                  *
206:                  * Output:      None
207:                  *
208:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
209:                  *
210:                  ********************************************************************/
211:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
212:                 {
213:                     unsigned int dma_status;
214:                     unsigned int int_status;
215:                     __OSCCONbits_t oscBits;
216:                 
217:                     mSYSTEMUnlock(int_status, dma_status);
9D00006C  0F400760   JAL INTDisableInterrupts
9D000070  00000000   NOP
9D000074  AFC20024   SW V0, 36(S8)
9D0000BC  AFC2002C   SW V0, 44(S8)
9D0000C0  3C02BF81   LUI V0, -16511
9D0000C4  AC40F230   SW ZERO, -3536(V0)
9D0000C8  3C02BF81   LUI V0, -16511
9D0000CC  3C03AA99   LUI V1, -21863
9D0000D0  34636655   ORI V1, V1, 26197
9D0000D4  AC43F230   SW V1, -3536(V0)
9D0000D8  3C02BF81   LUI V0, -16511
9D0000DC  3C035566   LUI V1, 21862
9D0000E0  346399AA   ORI V1, V1, -26198
9D0000E4  AC43F230   SW V1, -3536(V0)
218:                 
219:                     oscBits.w=OSCCON;       // read to be in sync. flush any pending write
9D0000E8  3C02BF81   LUI V0, -16511
9D0000EC  8C42F000   LW V0, -4096(V0)
9D0000F0  AFC20044   SW V0, 68(S8)
220:                     oscBits.PBDIV=0;
9D0000F4  8FC20044   LW V0, 68(S8)
9D0000F8  7C02A4C4   INS V0, ZERO, 19, 2
9D0000FC  AFC20044   SW V0, 68(S8)
221:                     oscBits.w|=oscPbDiv;
9D000100  8FC30044   LW V1, 68(S8)
9D000104  8FC20020   LW V0, 32(S8)
9D000108  00621025   OR V0, V1, V0
9D00010C  AFC20044   SW V0, 68(S8)
222:                     OSCCON=oscBits.w;       // write back
9D000110  8FC30044   LW V1, 68(S8)
9D000114  3C02BF81   LUI V0, -16511
9D000118  AC43F000   SW V1, -4096(V0)
223:                     oscBits.w=OSCCON;       // make sure the write occurred before returning from this function
9D00011C  3C02BF81   LUI V0, -16511
9D000120  8C42F000   LW V0, -4096(V0)
9D000124  AFC20044   SW V0, 68(S8)
224:                 
225:                     mSYSTEMLock(int_status, dma_status);
9D000128  3C02BF81   LUI V0, -16511
9D00012C  3C033333   LUI V1, 13107
9D000130  34633333   ORI V1, V1, 13107
9D000134  AC43F230   SW V1, -3536(V0)
9D000138  8FC2002C   LW V0, 44(S8)
9D00013C  AFC20030   SW V0, 48(S8)
9D0001A0  8FC40024   LW A0, 36(S8)
9D0001A4  0F40073F   JAL INTRestoreInterrupts
9D0001A8  00000000   NOP
226:                 }
227:                 
228:                 #define     mOSCSetPBDIV        OSCSetPBDIV     // backward compatibility
229:                 
230:                 
231:                 
232:                     /******************************************************************************
233:                      * Available options for config parameter
234:                      *****************************************************************************/
235:                         // CPU Peripheral Bus divisor values - values are mutually exclusive
236:                         #define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
237:                         #define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
238:                         #define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
239:                         #define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
240:                     /***********************************
241:                      * End config parameter values
242:                      ************************************/
243:                 
244:                 
245:                 /*********************************************************************
246:                  * Function:    mOSCGetPBDIV()
247:                  *
248:                  * Description: Reads peripheral bus divisor
249:                  *
250:                  * PreCondition:None
251:                  *
252:                  * Inputs:      None
253:                  *
254:                  * Output:      None
255:                  *
256:                  * Example:     mOSCGetPBDIV()
257:                  *
258:                  ********************************************************************/
259:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
260:                 
261:                 
262:                 /*********************************************************************
263:                  * Function:    mOSCClockFailStatus()
264:                  *
265:                  * Description: Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
266:                  *
267:                  * PreCondition: None
268:                  *
269:                  * Inputs:      None
270:                  *
271:                  * Output:      None
272:                  *
273:                  * Example:     mOSCClockFailStatus()
274:                  *
275:                  ********************************************************************/
276:                 #define mOSCClockFailStatus (OSCCONbits.CF)
277:                 
278:                 
279:                 /*********************************************************************
280:                  * Function:        mOSCEnableSOSC()
281:                  *
282:                  * Description:     Enables the LPRC
283:                  *
284:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
285:                  *
286:                  * Inputs:          None
287:                  *
288:                  * Output:          None
289:                  *
290:                  * Example:         mOSCEnableSOSC()
291:                  *
292:                  ********************************************************************/
293:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
294:                 
295:                 
296:                 /*********************************************************************
297:                  * Function:        mOSCDisableSOSC(config)
298:                  *
299:                  * Description:     Disables SOSC
300:                  *
301:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
302:                  *
303:                  * Inputs:          None
304:                  *
305:                  * Output:          None
306:                  *
307:                  * Example:         mOSCDisableSOSC()
308:                  *
309:                  ********************************************************************/
310:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
311:                 
312:                 
313:                 
314:                 #endif
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ----------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:    xc.h
8:                    *                  int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the “Company”) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Company’s customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_5XX_6XX__7XX_H_
43:                  #define _DMA_5XX_6XX__7XX_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  /*
48:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
49:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
50:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
51:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
52:                  */
53:                  #ifndef _SUPPRESS_PLIB_WARNING
54:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
55:                  #endif
56:                  
57:                  
58:                  // DMA definitions
59:                  
60:                  #ifdef _DMAC0
61:                      #define _DMA_CHANNELS       // DMA channels exist
62:                  
63:                  
64:                  // existent DMA channels
65:                      typedef enum
66:                      {
67:                          DMA_CHANNEL0,
68:                      #ifdef _DMAC1
69:                          DMA_CHANNEL1,
70:                      #ifdef _DMAC2
71:                          DMA_CHANNEL2,
72:                      #ifdef _DMAC3
73:                          DMA_CHANNEL3,
74:                      #ifdef _DMAC4
75:                          DMA_CHANNEL4,
76:                      #ifdef _DMAC5
77:                          DMA_CHANNEL5,
78:                      #ifdef _DMAC6
79:                          DMA_CHANNEL6,
80:                      #ifdef _DMAC7
81:                          DMA_CHANNEL7,
82:                      #endif  // _DMAC7
83:                      #endif  // _DMAC6
84:                      #endif  // _DMAC5
85:                      #endif  // _DMAC4
86:                      #endif  // _DMAC3
87:                      #endif  // _DMAC2
88:                      #endif  // _DMAC1
89:                          //  add/remove DMA channel as needed here
90:                  
91:                          DMA_CHANNELS    // number of current available channels
92:                      }DmaChannel;
93:                  
94:                  
95:                      // Relative Dma channels priority, between each other
96:                      typedef enum
97:                      {
98:                          DMA_CHN_PRI0,
99:                          DMA_CHN_PRI1,
100:                         DMA_CHN_PRI2,
101:                         DMA_CHN_PRI3
102:                     }DmaChannelPri;
103:                 
104:                 
105:                 
106:                     // high level definitions for the API functions
107:                 
108:                     typedef enum
109:                     {
110:                         DMA_OPEN_DEFAULT = 0,                                   // DMA default operation
111:                         DMA_OPEN_AUTO   = _DCH0CON_CHAEN_MASK,                  // DMA channel is auto enabled
112:                         DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),   // DMA channel is chained to lower channel
113:                         DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),             // DMA channel is chained to higher channel
114:                         DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,                  // events detection enabled while channel off
115:                         DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,                   // DMA channel is enabled after open
116:                         DMA_OPEN_MATCH  = 0x80000000,                           // DMA channel stops on match
117:                     }DmaOpenFlags;  // flags for the channel open
118:                 
119:                 
120:                     typedef enum
121:                     {
122:                         DMA_EV_ERR =            0x1,        // address error event
123:                         DMA_EV_ABORT =          0x2,        // transfer abort event
124:                         DMA_EV_CELL_DONE =      0x4,        // cell transfer complete event
125:                         DMA_EV_BLOCK_DONE =     0x8,        // block transfer complete event
126:                         DMA_EV_DST_HALF =       0x10,       // destination half event
127:                         DMA_EV_DST_FULL =       0x20,       // destination full event
128:                         DMA_EV_SRC_HALF =       0x40,       // source half event
129:                         DMA_EV_SRC_FULL =       0x80,       // source full event
130:                 
131:                         DMA_EV_ALL_EVNTS=       (DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
132:                                                     DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)                // all available events
133:                     }DmaEvFlags;    // flags for controlling the DMA channel events; Bit fields from the processor header file.
134:                 
135:                 
136:                     typedef enum
137:                     {
138:                         DMA_TXFER_OK,           // the transfer was performed successfully
139:                         DMA_TXFER_ADD_ERR,      // address error while performing the transfer
140:                         DMA_TXFER_ABORT,        // the DMA transfer was aborted
141:                         DMA_TXFER_BC_ERR,       // block complete not set after the DMA transfer performed
142:                         DMA_TXFER_CC_ERR,       // cell complete not set after the DMA transfer performed
143:                         DMA_TXFER_TMO           // DMA transfer timeout
144:                     }DmaTxferRes;       // DMA transfer result
145:                 
146:                     typedef enum
147:                     {
148:                         DMA_WAIT_NOT,       // don't wait for the transfer to complete, return immediately
149:                         DMA_WAIT_CELL,      // wait for the cell transfer to complete, than return
150:                         DMA_WAIT_BLOCK      // wait for the block transfer to complete, than return
151:                     }DmaWaitMode;       // DMA transfer wait mode
152:                 
153:                     typedef enum
154:                     {
155:                         DMA_CHKSUM_CRC,     // LFSR CRC
156:                         DMA_CHKSUM_IP,      // IP Checksum
157:                     }DmaChksumType;     // DMA SFM supported checksum types
158:                 
159:                     typedef enum
160:                     {
161:                         DMA_BITO_MSb,       // MSb first (not reflected)
162:                         DMA_BITO_LSb,       // LSb first (reflected)
163:                     }DmaBitOrder;       // DMA SFM supported bit ordering
164:                 
165:                     typedef enum
166:                     {
167:                         DMA_REORDER_NOT,    // no reordering, destination matches the source
168:                         DMA_REORDER_ENDIAN, // change endianess on word (32 bit) boundaries: LE<->BE
169:                         DMA_REORDER_SWAP_HALF,  // swap half words (16 bit) within word (32 bit)
170:                         DMA_REORDER_SWAP_BYTE,  // swap bytes within half word (16 bit)
171:                     }DmaReorderMode;    // DMA SFM supported re-ordering modes
172:                 
173:                 
174:                     /*********************************************************************
175:                      * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
176:                      *
177:                      * PreCondition:    chPri  - valid channel priority, 0-3
178:                      *
179:                      * Input:           chn    - channel to be configured in the DMA controller
180:                      *                  chPri  - the priority given to the channel, 0-3
181:                      *                  oFlags - orred flags specifying the open mode:
182:                      *                           DMA_OPEN_DEFAULT: DMA default operation mode
183:                      *                           DMA_OPEN_AUTO: DMA channel is auto enabled
184:                      *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
185:                      *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
186:                      *                           DMA_OPEN_DET_EN: events detection enabled while channel off
187:                      *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
188:                      *                           DMA_OPEN_MATCH:    DMA channel stops on match
189:                      *
190:                      *
191:                      *
192:                      * Output:          None
193:                      *
194:                      * Side Effects:    None
195:                      *
196:                      * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
197:                      *
198:                      * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
199:                      *                  Use the low level functions to address special settings.
200:                      *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
201:                      *                  After that the channel is configured.
202:                      *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
203:                      *                  if DMA_OPEN_ENABLE flag was not specified.
204:                      *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
205:                      *                  This way, the transfer will occur correctly together with CRC calculation.
206:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
207:                      *                  User has to call event channel functions to enable the event flags if needed.
208:                      *
209:                      * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
210:                      ********************************************************************/
211:                      void           DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
212:                 
213:                     /*********************************************************************
214:                      * Function:        void DmaChnEnable(DmaChannel chn)
215:                      *
216:                      * PreCondition:    None
217:                      *
218:                      * Input:           chn     - channel to be enabled
219:                      *
220:                      * Output:          None
221:                      *
222:                      * Side Effects:    None
223:                      *
224:                      * Overview:        The function enables a previously configured DMA channel.
225:                      *
226:                      * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
227:                      *
228:                      * Example:         DmaChnEnable(DMA_CHANNEL3);
229:                      ********************************************************************/
230:                      void           DmaChnEnable(DmaChannel chn);
231:                 
232:                     /*********************************************************************
233:                      * Function:        void DmaChnDisable(DmaChannel chn)
234:                      *
235:                      * PreCondition:    None
236:                      *
237:                      * Input:           chn     - selected channel in the DMA controller
238:                      *
239:                      * Output:          None
240:                      *
241:                      * Side Effects:    None
242:                      *
243:                      * Overview:        The function disables a DMA channel. The channel operation stops.
244:                      *
245:                      * Note:            None.
246:                      *
247:                      * Example:         DmaChnDisable(DMA_CHANNEL3);
248:                      ********************************************************************/
249:                      void           DmaChnDisable(DmaChannel chn);
250:                 
251:                     /*********************************************************************
252:                      * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
253:                      *
254:                      * PreCondition:    chn     - valid DMA channel
255:                      *              - vSrcAdd, vDstAdd  - valid pointers
256:                      *                              - 0 < srcSize <= DmaGetMaxTxferSize()
257:                      *                              - 0 < dstSize <= DmaGetMaxTxferSize()
258:                      *                              - 0 < cellSize <= DmaGetMaxTxferSize()
259:                      *
260:                      * Input:           chn         - DMA channel number
261:                      *                              - vSrcAdd: source of the DMA transfer
262:                      *                              - vDstAdd: destination of the DMA transfer
263:                      *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
264:                      *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
265:                      *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
266:                      *
267:                      * Output:          None
268:                      *
269:                      * Side Effects:    None
270:                      *
271:                      * Overview:        The function sets the transfer characteristics for a DMA channel transfer:
272:                      *                  the source and the destination addresses.
273:                      *                  the source and destination lengths
274:                      *                  and the number of bytes transferred per event.
275:                      *
276:                      * Note:            The function clears the existing DMA channel event flags.
277:                      *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
278:                      *
279:                      * Example:         DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
280:                      ********************************************************************/
281:                      void           DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
282:                 
283:                 
284:                     /*********************************************************************
285:                      * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
286:                      *
287:                      * PreCondition:    chn     - valid DMA channel
288:                      *
289:                      * Input:           chn     - DMA channel number
290:                      *              - vSrcAdd: source (virtual) of the DMA transfer
291:                      * Output:          None
292:                      *
293:                      * Side Effects:    None
294:                      *
295:                      * Overview:        The function is a helper to set directly the transfer source address.
296:                      *
297:                      * Note:            None.
298:                      *
299:                      * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
300:                      ********************************************************************/
301:                      void           DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
302:                 
303:                     /*********************************************************************
304:                      * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
305:                      *
306:                      * PreCondition:    chn     - valid DMA channel
307:                      *
308:                      * Input:           chn         - DMA channel number
309:                      *                              - vDstAdd: destination (virtual) of the DMA transfer
310:                      * Output:          None
311:                      *
312:                      * Side Effects:    None
313:                      *
314:                      * Overview:        The function is a helper to set directly the transfer destination address.
315:                      *
316:                      * Note:            None
317:                      *
318:                      * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
319:                      ********************************************************************/
320:                      void           DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
321:                 
322:                     /*********************************************************************
323:                      * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
324:                      *
325:                      * PreCondition:    chn - valid DMA channel
326:                      *
327:                      * Input:           chn     - DMA channel number
328:                      *                  pattern -  the match pattern
329:                      *
330:                      * Output:          None
331:                      *
332:                      * Side Effects:    None
333:                      *
334:                      * Overview:        The function sets the curent match pattern for the selected DMA channel.
335:                      *
336:                      * Note:            None.
337:                      *
338:                      * Example:         DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
339:                      ********************************************************************/
340:                      void           DmaChnSetMatchPattern(DmaChannel chn, int pattern);
341:                 
342:                     /*********************************************************************
343:                      * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
344:                      *
345:                      * PreCondition:    chn - valid DMA channel
346:                      *
347:                      * Input:           chn     - DMA channel number
348:                      *
349:                      * Output:          The channel match pattern.
350:                      *
351:                      * Side Effects:    None
352:                      *
353:                      * Overview:        The function retrieves the curent match pattern for the selected DMA channel.
354:                      *
355:                      * Note:            None.
356:                      *
357:                      * Example:         int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
358:                      ********************************************************************/
359:                      int            DmaChnGetMatchPattern(DmaChannel chn);
360:                 
361:                     /*********************************************************************
362:                      * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
363:                      *
364:                      * PreCondition:    chn - valid DMA channel
365:                      *
366:                      * Input:           chn     - DMA channel number
367:                      *                  wMode   - if DMA_WAIT_NOT, return immediately
368:                      *                          - if DMA_WAIT_CELL, return after the cell transfer complete
369:                      *                          - if DMA_WAIT_BLOCK, return after the whole transfer is done
370:                      *                  retries - retry counter: if transfer not complete after so many retries, return with tmo.
371:                      *                              If 0, wait forever.
372:                      *
373:                      * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
374:                      *                  an DmaTxferRes error code  otherwise
375:                      *
376:                      * Side Effects:    None
377:                      *
378:                      * Overview:        The function initiates (forces) a DMA transfer for the selected DMA channel.
379:                      *                  The DMA channel is enabled.
380:                      *                  If waiting for the transfer completion needed (user doesn't use an ISR to catch
381:                      *                  this event) the function will periodically query the DMA controller for the
382:                      *                  transfer completion status.
383:                      *                  If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
384:                      *                  the block transfer than the function will re-force the transfer for each cell.
385:                      *
386:                      * Note:            This function can not ne used when the DMA channel is triggerred
387:                      *                  by hardware interrupt requests.
388:                      *                  This is because the transfers are software forced, theere is no
389:                      *                  wait for the occurrence of the hardware trigger.
390:                      *
391:                      * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
392:                      ********************************************************************/
393:                      DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
394:                 
395:                     /*********************************************************************
396:                      * Function:        void DmaChnForceTxfer(DmaChannel chn)
397:                      *
398:                      * PreCondition:    chn - valid DMA channel
399:                      *
400:                      * Input:           chn     - DMA channel number
401:                      *
402:                      * Output:          None
403:                      *
404:                      * Side Effects:    None
405:                      *
406:                      * Overview:        The function forces a DMA transfer to occur for the selected DMA channel.
407:                      *
408:                      * Note:            None.
409:                      *
410:                      * Example:         DmaChnForceTxfer(DMA_CHANNEL3);
411:                      ********************************************************************/
412:                      void           DmaChnForceTxfer(DmaChannel chn);
413:                 
414:                     /*********************************************************************
415:                      * Function:        void DmaChnAbortTxfer(DmaChannel chn)
416:                      *
417:                      * PreCondition:    chn - valid DMA channel
418:                      *
419:                      * Input:           chn     - DMA channel number
420:                      *
421:                      * Output:          None
422:                      *
423:                      * Side Effects:    None
424:                      *
425:                      * Overview:        The function aborts a current undergoing DMA transfer for the selected DMA channel.
426:                      *
427:                      * Note:            None.
428:                      *
429:                      * Example:         DmaChnAbortTxfer(DMA_CHANNEL3);
430:                      ********************************************************************/
431:                      void           DmaChnAbortTxfer(DmaChannel chn);
432:                 
433:                     // High level channel event and interrupt control functions
434:                 
435:                     /*********************************************************************
436:                      * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
437:                      *
438:                      * PreCondition:    chn - valid DMA channel
439:                      *
440:                      * Input:           chn     - DMA channel number
441:                      *                  eFlags  - event flags with the following significance:
442:                      *                              - DMA_EV_ERR: address error event
443:                      *                              - DMA_EV_ABORT: transfer abort event
444:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
445:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
446:                      *                              - DMA_EV_DST_HALF: destination half event
447:                      *                              - DMA_EV_DST_FULL: destination full event
448:                      *                              - DMA_EV_SRC_HALF: source half event
449:                      *                              - DMA_EV_SRC_FULL: source full event
450:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
451:                      *
452:                      * Output:          None
453:                      *
454:                      * Side Effects:    None
455:                      *
456:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
457:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
458:                      *                  enabled for the selected channel, the other channel event flags won't be touched.
459:                      *
460:                      * Note:            None.
461:                      *
462:                      * Example:         DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
463:                      ********************************************************************/
464:                      void           DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
465:                 
466:                     /*********************************************************************
467:                      * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
468:                      *
469:                      * PreCondition:    chn - valid DMA channel
470:                      *
471:                      * Input:           chn     - DMA channel number
472:                      *                  eFlags  - event flags with the following significance:
473:                      *                              - DMA_EV_ERR: address error event
474:                      *                              - DMA_EV_ABORT: transfer abort event
475:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
476:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
477:                      *                              - DMA_EV_DST_HALF: destination half event
478:                      *                              - DMA_EV_DST_FULL: destination full event
479:                      *                              - DMA_EV_SRC_HALF: source half event
480:                      *                              - DMA_EV_SRC_FULL: source full event
481:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
482:                      *
483:                      * Output:          None
484:                      *
485:                      * Side Effects:    None
486:                      *
487:                      * Overview:        The function clears the event enable flags for the selected DMA channel.
488:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
489:                      *                  disabled for the selected channel, the other channel event flags won't be touched.
490:                      *
491:                      * Note:            None.
492:                      *
493:                      * Example:         DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
494:                      ********************************************************************/
495:                      void           DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
496:                 
497:                     /*********************************************************************
498:                      * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
499:                      *
500:                      * PreCondition:    chn - valid DMA channel
501:                      *
502:                      * Input:           chn     - DMA channel number
503:                      *                  eFlags  - event flags with the following significance:
504:                      *                              - DMA_EV_ERR: address error event
505:                      *                              - DMA_EV_ABORT: transfer abort event
506:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
507:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
508:                      *                              - DMA_EV_DST_HALF: destination half event
509:                      *                              - DMA_EV_DST_FULL: destination full event
510:                      *                              - DMA_EV_SRC_HALF: source half event
511:                      *                              - DMA_EV_SRC_FULL: source full event
512:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
513:                      *
514:                      * Output:          None
515:                      *
516:                      * Side Effects:    None
517:                      *
518:                      * Overview:        The function sets the event enable flags for the selected DMA channel.
519:                      *                  The channel event flags are forced to the eFlags value.
520:                      *
521:                      * Note:            None.
522:                      *
523:                      * Example:         DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
524:                      ********************************************************************/
525:                      void           DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
526:                 
527:                     /*********************************************************************
528:                      * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
529:                      *
530:                      * PreCondition:    chn - valid DMA channel
531:                      *
532:                      * Input:           chn     - DMA channel number
533:                      *
534:                      * Output:          - event flags with the following significance:
535:                      *                      - DMA_EV_ERR: address error event
536:                      *                      - DMA_EV_ABORT: transfer abort event
537:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
538:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
539:                      *                      - DMA_EV_DST_HALF: destination half event
540:                      *                      - DMA_EV_DST_FULL: destination full event
541:                      *                      - DMA_EV_SRC_HALF: source half event
542:                      *                      - DMA_EV_SRC_FULL: source full event
543:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
544:                      *
545:                      * Side Effects:    None
546:                      *
547:                      * Overview:        The function returns the event enabled flags for the selected DMA channel.
548:                      *
549:                      * Note:            None.
550:                      *
551:                      * Example:         DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
552:                      ********************************************************************/
553:                      DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn);
554:                 
555:                     /*********************************************************************
556:                      * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
557:                      *
558:                      * PreCondition:    chn - valid DMA channel
559:                      *
560:                      * Input:           chn     - DMA channel number
561:                      *                  eFlags  - event flags with the following significance:
562:                      *                              - DMA_EV_ERR: address error event
563:                      *                              - DMA_EV_ABORT: transfer abort event
564:                      *                              - DMA_EV_CELL_DONE: cell transfer complete event
565:                      *                              - DMA_EV_BLOCK_DONE: block transfer complete event
566:                      *                              - DMA_EV_DST_HALF: destination half event
567:                      *                              - DMA_EV_DST_FULL: destination full event
568:                      *                              - DMA_EV_SRC_HALF: source half event
569:                      *                              - DMA_EV_SRC_FULL: source full event
570:                      *                              - DMA_EV_ALL_EVNTS: all of the above flags
571:                      *
572:                      * Output:          None
573:                      *
574:                      * Side Effects:    None
575:                      *
576:                      * Overview:        The function clears the event flags for the selected DMA channel.
577:                      *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
578:                      *                  cleared for the selected channel, the other channel event flags won't be touched.
579:                      *
580:                      * Note:            None.
581:                      *
582:                      * Example:         DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
583:                      ********************************************************************/
584:                      void           DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
585:                 
586:                     /*********************************************************************
587:                      * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
588:                      *
589:                      * PreCondition:    chn - valid DMA channel
590:                      *
591:                      * Input:           chn     - DMA channel number
592:                      *
593:                      * Output:          event flags with the following significance:
594:                      *                      - DMA_EV_ERR: address error event
595:                      *                      - DMA_EV_ABORT: transfer abort event
596:                      *                      - DMA_EV_CELL_DONE: cell transfer complete event
597:                      *                      - DMA_EV_BLOCK_DONE: block transfer complete event
598:                      *                      - DMA_EV_DST_HALF: destination half event
599:                      *                      - DMA_EV_DST_FULL: destination full event
600:                      *                      - DMA_EV_SRC_HALF: source half event
601:                      *                      - DMA_EV_SRC_FULL: source full event
602:                      *                      - DMA_EV_ALL_EVNTS: all of the above flags
603:                      *
604:                      * Side Effects:    None
605:                      *
606:                      * Overview:        The function returns the event flags for the selected DMA channel.
607:                      *
608:                      * Note:            None.
609:                      *
610:                      * Example:         DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
611:                      ********************************************************************/
612:                      DmaEvFlags DmaChnGetEvFlags(DmaChannel chn);
613:                 
614:                 
615:                     // high level helpers for fast strcpy/memcpy transfers
616:                 
617:                     /*********************************************************************
618:                      * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
619:                      *
620:                      * PreCondition:    chn     - a valid DMA channel
621:                      *                  s1, s2  - valid memory pointers
622:                      *                  n>0, n<=DmaGetMaxTxferSize()
623:                      *
624:                      * Input:           s1      - destination pointer
625:                      *                  s2      - source pointer
626:                      *                  n       - number of bytes to transfer
627:                      *                  chn     - the DMA channel to perform the transfer
628:                      *                  chPri   - the desired channel priority
629:                      *
630:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
631:                      *                  an DmaTxferRes error code  otherwise
632:                      *
633:                      * Side Effects:    None
634:                      *
635:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
636:                      *          Then it copies one block of memory from source to destination.
637:                      *
638:                      *
639:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
640:                      *                    This way, the transfer will occur correctly together with checksum calculation.
641:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
642:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
643:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
644:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
645:                      *
646:                      * Example:     res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
647:                      ********************************************************************/
648:                      DmaTxferRes    DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
649:                 
650:                     /*********************************************************************
651:                      * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
652:                      *
653:                      * PreCondition:    chn     - a valid DMA channel
654:                      *                  s1, s2  - valid memory pointers
655:                      *
656:                      * Input:           s1      - destination pointer
657:                      *                  s2      - source pointer
658:                      *                  chn     - the DMA channel to perform the transfer
659:                      *                  chPri   - the desired channel priority
660:                      *
661:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
662:                      *                  an DmaTxferRes error code  otherwise
663:                      *
664:                      * Side Effects:    None
665:                      *
666:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
667:                      *          Then it copies one zero terminated string from source to destination.
668:                      *
669:                      *
670:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
671:                      *                    This way, the transfer will occur correctly together with checksum calculation.
672:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
673:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
674:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
675:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
676:                      *
677:                      *
678:                      * Example:     res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
679:                      *********************************************************************/
680:                      DmaTxferRes    DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
681:                 
682:                     /*********************************************************************
683:                      * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
684:                      *
685:                      * PreCondition:    chn     - a valid DMA channel
686:                      *              - s1, s2    - valid memory pointers
687:                      *                              - 0 < n <= DmaGetMaxTxferSize()
688:                      *
689:                      * Input:           s1      - destination pointer
690:                      *                  s2      - source pointer
691:                      *                  n   - max number of bytes to transfer
692:                      *                  chn     - the DMA channel to perform the transfer
693:                      *                  chPri   - the desired channel priority
694:                      *
695:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
696:                      *                  an DmaTxferRes error code  otherwise
697:                      *
698:                      * Side Effects:    None
699:                      *
700:                      * Overview:        The function configures a DMA channel for a fast memory transfer.
701:                      *          Then it copies one zero terminated string from source to destination.
702:                      *          It copies no more than n characters from s2.
703:                      *
704:                      *
705:                      * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
706:                      *                    This way, the transfer will occur correctly together with checksum calculation.
707:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
708:                      *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
709:                      *                  - The function clears the suspend state and resumes the operation of the DMA controller.
710:                      *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
711:                      *
712:                      *
713:                      * Example:     res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
714:                      ********************************************************************/
715:                      DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
716:                 
717:                     /*********************************************************************
718:                      * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
719:                      *
720:                      * PreCondition:    chn    - a valid DMA channel
721:                      *                  d, s   - valid memory pointer
722:                      *                  n>0, n<=DmaGetMaxTxferSize()
723:                      *
724:                      * Input:           d     - address where to deposit the result
725:                      *                  s     - source buffer pointer
726:                      *                  n     - number of bytes in the pointer
727:                      *                  chn   - the DMA channel to use
728:                      *                  chPri - the desired channel priority
729:                      *
730:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
731:                      *                  an DmaTxferRes error code  otherwise
732:                      *
733:                      * Side Effects:    None
734:                      *
735:                      * Overview:        The function is a helper that calculates the CRC of a memory block.
736:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
737:                      *
738:                      *
739:                      * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
740:                      *                  - No transfer is done, just the CRC is calculated.
741:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
742:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
743:                      *                  - The checksum type is switched to CRC.
744:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
745:                      *
746:                      * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
747:                      ********************************************************************/
748:                      DmaTxferRes    DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
749:                 
750:                     /*********************************************************************
751:                      * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
752:                      *
753:                      * PreCondition:    chn    - a valid DMA channel
754:                      *                  d, s   - valid memory pointer
755:                      *                  n>0, n<=DmaGetMaxTxferSize()
756:                      *
757:                      * Input:           d     - address where to deposit the result
758:                      *                  s     - source buffer pointer
759:                      *                  n     - number of bytes in the pointer
760:                      *                  chn   - the DMA channel to use
761:                      *                  chPri - the desired channel priority
762:                      *
763:                      * Output:          DMA_TXFER_OK if the transfer ended normally,
764:                      *                  an DmaTxferRes error code  otherwise
765:                      *
766:                      * Side Effects:    None
767:                      *
768:                      * Overview:        The function is a helper that calculates the IP checksum of a memory block.
769:                      *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
770:                      *
771:                      *
772:                      * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
773:                      *                  - No transfer is done, just the checksum is calculated.
774:                      *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
775:                      *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
776:                      *                  - The checksum type is switched to IP checksum.
777:                      *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
778:                      *
779:                      * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
780:                      ********************************************************************/
781:                      DmaTxferRes    DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
782:                 
783:                     // High level Special Function Module (SFM) functions
784:                 
785:                     /*********************************************************************
786:                      * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
787:                      *
788:                      * PreCondition:    cType, bitO, rMode - valid values
789:                      *
790:                      * Input:           cType - checksum type to be calculated: CRC or IP Checksum
791:                      *                  bitO  - the bit order to be used MSb or LSb first
792:                      *                  rMode - the reordering mode of the bytes when calculating the checksum
793:                      *
794:                      * Output:          None
795:                      *
796:                      * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
797:                      *
798:                      * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
799:                      *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
800:                      *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first)
801:                      *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
802:                      *                      All these values affect the way the checksum is calculated.
803:                      *
804:                      * Note:            None
805:                      *
806:                      * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
807:                      ********************************************************************/
808:                     extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
809:                     {
810:                         DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
811:                         DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
812:                     }
813:                 
814:                     /*********************************************************************
815:                      * Function:        void DmaSfmTxferReorder(int enable)
816:                      *
817:                      * PreCondition:    None
818:                      *
819:                      * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
820:                      *
821:                      * Output:          None
822:                      *
823:                      * Side Effects:    None
824:                      *
825:                      * Overview:        The function configures the data transfer re-ordering of the SFM module.
826:                      *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
827:                      *                  Otherwise the data is written to the destination un-modified.
828:                      *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
829:                      *
830:                      *
831:                      * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
832:                      *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
833:                      *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
834:                      *                    Un-aligned transfers are not supported (undefined behavior)!
835:                      *
836:                      * Example:         DmaSfmTxferReorder();
837:                      ********************************************************************/
838:                     extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
839:                     {
840:                         DCRCCONCLR=_DCRCCON_WBO_MASK;
841:                         DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
842:                     }
843:                 
844:                 
845:                      /*********************************************************************
846:                      * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
847:                      *
848:                      * PreCondition:    pLen   - valid polynomial length within 1-32
849:                      *
850:                      * Input:           polynomial  - the layout of the CRC generator
851:                      *                  pLen        - the length of the CRC generator polynomial
852:                      *                  seed        - the initial seed of the CRC generator
853:                      *
854:                      * Output:          None
855:                      *
856:                      * Side Effects:    None
857:                      *
858:                      * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
859:                      *                  - the length of the CRC generator polynomial, pLen;
860:                      *                  - the function sets the layout of the shift stages that take place in the CRC generation.
861:                      *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
862:                      *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
863:                      *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
864:                      *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
865:                      *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
866:                      *                  - the function sets the seed of the CRC generator. This is the initial data present in the
867:                      *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
868:                      *
869:                      * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
870:                      *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
871:                      *                    Upon the transfer completion the calculated CRC is stored at the destination address.
872:                      *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
873:                      *                    the CrcResult() function.
874:                      *                  - The CRC module should be configured before enabled.
875:                      *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
876:                      *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
877:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
878:                      *
879:                      * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
880:                      ********************************************************************/
881:                     extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
882:                     {
883:                         DCRCCONCLR=_DCRCCON_PLEN_MASK;
884:                         DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
885:                         DCRCDATA=seed;
886:                         DCRCXOR=polynomial;
887:                     }
888:                 
889:                     #define DmaCrcConfigure DmaSfmCrcConfigure  // PIC32_3xx backward compatibility name
890:                 
891:                 
892:                     /*********************************************************************
893:                      * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
894:                      *
895:                      * PreCondition:    chn    - valid DMA channel
896:                      *
897:                      * Input:           chn         - the DMA channel to be attached to the checksum module.
898:                      *                  appendMode  - if TRUE the data passed to the checksum generator is not transferred to destination
899:                      *                                but it's written to the destination address when the block transfer is complete.
900:                      *                              - if FALSE the data is transferred normally while the checksum is calculated.
901:                      *                                The checksum will be available using the DmaSfmChecksum function.
902:                      *
903:                      * Output:          None
904:                      *
905:                      * Side Effects:    None
906:                      *
907:                      * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
908:                      *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
909:                      *                  is complete, the checksum result is available in the checksum data register.
910:                      *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
911:                 
912:                      *
913:                      * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
914:                      *
915:                      * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
916:                      ********************************************************************/
917:                     void            DmaSfmAttachChannel(DmaChannel chn, int appendMode);
918:                     #define         CrcAttachChannel    DmaSfmAttachChannel     // PIC32_3xx backward compatibility name
919:                 
920:                     /*********************************************************************
921:                      * Function:        unsigned int DmaSfmChecksum(void)
922:                      *
923:                      * PreCondition:    None
924:                      *
925:                      * Input:           None
926:                      *
927:                      * Output:          the current value of the checksum generator.
928:                      *
929:                      * Side Effects:    None
930:                      *
931:                      * Overview:        The function returns the calculated checksum value.
932:                      *
933:                      * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
934:                      *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
935:                      *
936:                      * Example:         unsigned int myChk=DmaSfmChecksum();
937:                      ********************************************************************/
938:                     extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
939:                     {
940:                         return DCRCDATA;
941:                     }
942:                     #define     CrcResult   DmaSfmChecksum      // PIC32_3xx backward compatibility name
943:                     #define     DmaCrcGetValue  DmaSfmChecksum      // PIC32_3xx backward compatibility name
944:                 
945:                 
946:                     /*********************************************************************
947:                      * Function:        void DmaSfmSetSeed(unsigned int seed)
948:                      *
949:                      * PreCondition:    None
950:                      *
951:                      * Input:           seed    - the initial seed of the checksum generator
952:                      *
953:                      * Output:          None
954:                      *
955:                      * Side Effects:    None
956:                      *
957:                      * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
958:                      *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
959:                      *
960:                      * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
961:                      *
962:                      * Example:         DmaSfmSetSeed(0xffffffff);
963:                      ********************************************************************/
964:                     extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
965:                     {
966:                         DCRCDATA=seed;
967:                     }
968:                     #define     DmaCrcSetSeed   DmaSfmSetSeed       // PIC32_3xx backward compatibility name
969:                 
970:                 
971:                 /*********************  end of high level functions ****************************************/
972:                 
973:                     // low level definitions for the API functions
974:                 
975:                 
976:                     typedef struct
977:                     {
978:                         union
979:                         {
980:                             struct
981:                             {
982:                                 unsigned int chn:   3;      // last active DMA channel
983:                                 unsigned int rdOp:  1;      // last DMA operation, read if 1, write if 0
984:                             };
985:                             unsigned int    w;                      // word access
986:                         }lastAccess;
987:                         void*   lastAddress;        // most recent DMA address
988:                     }DmaStatus;         // DMA controller status
989:                 
990:                     typedef enum
991:                     {
992:                         DMA_GFLG_SUSPEND =  _DMACON_SUSPEND_MASK,   // suspend DMA controller operation
993:                         DMA_GFLG_ON =       _DMACON_ON_MASK,        // DMA module enabled/desabled
994:                         //
995:                         DMA_GFLG_ALL_FLAGS= DMA_GFLG_SUSPEND|DMA_GFLG_ON        // all flags
996:                     }DmaGlblFlags;  // flags for controlling global DMA controller behavior. From processor header file.
997:                 
998:                 
999:                 
1000:                
1001:                    typedef enum
1002:                    {
1003:                        DMA_EV_ABORT_IRQ_EN =       _DCH0ECON_AIRQEN_MASK,
1004:                        DMA_EV_START_IRQ_EN =       _DCH0ECON_SIRQEN_MASK,
1005:                        // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
1006:                        // the start and abort IRQ signals
1007:                        DMA_EV_MATCH_EN =           _DCH0ECON_PATEN_MASK,
1008:                
1009:                
1010:                        // compiler use only field
1011:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1012:                    }DmaEvCtrlFlags;    /*DMA channel event control fields accessible as flags also
1013:                                          part of DmaEvCtrlFlags:
1014:                                        */
1015:                    #define DMA_EV_START_IRQ(irq)   (DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1016:                    #define DMA_EV_ABORT_IRQ(irq)   (DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))  // NOTE: irq has to be a symbol from the processor header file
1017:                
1018:                    // DMA channel event control as a structure:
1019:                    #define DmaEvCtrl   __DCH0ECONbits_t
1020:                
1021:                
1022:                
1023:                
1024:                    typedef enum
1025:                    {
1026:                        DMA_CTL_AUTO_EN =       _DCH0CON_CHAEN_MASK,
1027:                        DMA_CTL_CHAIN_EN =      _DCH0CON_CHCHN_MASK,
1028:                        DMA_CTL_DET_EN =        _DCH0CON_CHAED_MASK,
1029:                        DMA_CTL_CHN_EN =        _DCH0CON_CHEN_MASK,
1030:                        DMA_CTL_CHAIN_DIR =     _DCH0CON_CHCHNS_MASK,
1031:                        // use the DMA_CTL_PRI() below for selecting the DMA
1032:                        // channel priority
1033:                    }DmaChnCtrlFlags;   // controlling the DMA channel with flags
1034:                    // also part of DmaChnCtrlFlags:
1035:                    #define DMA_CTL_PRI(pri)    ((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1036:                
1037:                    // DMA channel control as a structure:
1038:                    #define DmaChnCtrl      __DCH0CONbits_t
1039:                
1040:                    typedef struct
1041:                    {
1042:                        void*   vSrcAdd;        // source of the DMA transfer, virtual
1043:                        void*   vDstAdd;        // destination of the DMA transfer, virtual
1044:                        int srcSize;        // source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1045:                        int dstSize;        // destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1046:                        int cellSize;       // no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1047:                    }DmaTxferCtrl;      // transfer setting: the transfer source, destination addresses and size, cell size
1048:                
1049:                
1050:                    /********************** low level DMA channel functions *******************************/
1051:                
1052:                
1053:                
1054:                    // Global DMA controller functions
1055:                
1056:                    /*********************************************************************
1057:                     * Function:        void DmaEnable(int enable)
1058:                     *
1059:                     * PreCondition:    None
1060:                     *
1061:                     * Input:           enable - boolean to enable/disable the DMA controller
1062:                     *
1063:                     * Output:          None
1064:                     *
1065:                     * Side Effects:    None
1066:                     *
1067:                     * Overview:       The function enables/disables the DMA controller.
1068:                     *
1069:                     * Note:           None.
1070:                     *
1071:                     * Example:        DmaEnable(1);
1072:                     ********************************************************************/
1073:                    extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1074:                    {
1075:                        if(enable)
1076:                        {
1077:                            DMACONSET=_DMACON_ON_MASK;
1078:                        }
1079:                        else
1080:                        {
1081:                            DMACONCLR=_DMACON_ON_MASK;
1082:                            while(DMACONbits.ON);       // wait to take effect
1083:                        }
1084:                    }
1085:                
1086:                    /*********************************************************************
1087:                     * Function:        void DmaReset(void)
1088:                     *
1089:                     * PreCondition:    None
1090:                     *
1091:                     * Input:       None
1092:                     *
1093:                     * Output:          None
1094:                     *
1095:                     * Side Effects:    None
1096:                     *
1097:                     * Overview:        The function resets the DMA controller.
1098:                     *
1099:                     * Note:            None.
1100:                     *
1101:                     * Example:        DmaReset();
1102:                     ********************************************************************/
1103:                    #define            DmaReset()   DmaEnable(0)
1104:                
1105:                
1106:                    /*********************************************************************
1107:                     * Function:        int DmaSuspend(void)
1108:                     *
1109:                     * PreCondition:    None
1110:                     *
1111:                     * Input:       None
1112:                     *
1113:                     * Output:          true if the DMA was previously suspended, false otherwise
1114:                     *
1115:                     *
1116:                     * Side Effects:    None
1117:                     *
1118:                     * Overview:        The function suspends the DMA controller.
1119:                     *
1120:                     * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1121:                     *                  I.e. the function has to wait for the suspension to take place!
1122:                     *
1123:                     * Example:         int susp=DmaSuspend();
1124:                     ********************************************************************/
1125:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1126:                    {
1127:                        int suspSt;
1128:                        if(!(suspSt=DMACONbits.SUSPEND))
9D000078  3C02BF88   LUI V0, -16504
9D00007C  8C423000   LW V0, 12288(V0)
9D000080  7C420300   EXT V0, V0, 12, 1
9D000084  304200FF   ANDI V0, V0, 255
9D000088  AFC20028   SW V0, 40(S8)
9D00008C  8FC20028   LW V0, 40(S8)
9D000090  14400009   BNE V0, ZERO, 0x9D0000B8
9D000094  00000000   NOP
9D00014C  3C02BF88   LUI V0, -16504
9D000150  8C423000   LW V0, 12288(V0)
9D000154  7C420300   EXT V0, V0, 12, 1
9D000158  304200FF   ANDI V0, V0, 255
9D00015C  AFC20034   SW V0, 52(S8)
9D000160  8FC20034   LW V0, 52(S8)
9D000164  1440000E   BNE V0, ZERO, 0x9D0001A0
9D000168  00000000   NOP
1129:                        {
1130:                            DMACONSET=_DMACON_SUSPEND_MASK;     // suspend
9D000098  3C02BF88   LUI V0, -16504
9D00009C  24031000   ADDIU V1, ZERO, 4096
9D0000A0  AC433008   SW V1, 12296(V0)
9D00016C  3C02BF88   LUI V0, -16504
9D000170  24031000   ADDIU V1, ZERO, 4096
9D000174  AC433008   SW V1, 12296(V0)
1131:                            while((DMACONbits.DMABUSY));    // wait to be actually suspended
9D0000A4  3C02BF88   LUI V0, -16504
9D0000A8  8C423000   LW V0, 12288(V0)
9D0000AC  30420800   ANDI V0, V0, 2048
9D0000B0  1440FFFC   BNE V0, ZERO, 0x9D0000A4
9D0000B4  00000000   NOP
9D000178  3C02BF88   LUI V0, -16504
9D00017C  8C423000   LW V0, 12288(V0)
9D000180  30420800   ANDI V0, V0, 2048
9D000184  1440FFFC   BNE V0, ZERO, 0x9D000178
9D000188  00000000   NOP
9D00018C  0B400068   J 0x9D0001A0
9D000190  00000000   NOP
1132:                        }
1133:                        return suspSt;
9D0000B8  8FC20028   LW V0, 40(S8)
1134:                    }
1135:                
1136:                
1137:                
1138:                    /*********************************************************************
1139:                     * Function:        void DmaResume(int susp)
1140:                     *
1141:                     * PreCondition:    None
1142:                     *
1143:                     * Input:       the desired DMA suspended state.
1144:                     *
1145:                     * Output:          None
1146:                     *
1147:                     * Side Effects:    None
1148:                     *
1149:                     * Overview:        The function restores the DMA controller activity to the old suspended mode.
1150:                     *
1151:                     * Note:            None.
1152:                     *
1153:                     * Example:         int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1154:                     ********************************************************************/
1155:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1156:                    {
1157:                        if(susp)
9D000140  8FC20030   LW V0, 48(S8)
9D000144  10400013   BEQ V0, ZERO, 0x9D000194
9D000148  00000000   NOP
1158:                        {
1159:                            DmaSuspend();
1160:                        }
1161:                        else
1162:                        {
1163:                            DMACONCLR=_DMACON_SUSPEND_MASK;     // resume DMA activity
9D000194  3C02BF88   LUI V0, -16504
9D000198  24031000   ADDIU V1, ZERO, 4096
9D00019C  AC433004   SW V1, 12292(V0)
1164:                        }
1165:                    }
1166:                
1167:                    /*********************************************************************
1168:                     * Function:        void DmaGetStatus(DmaStatus* pStat)
1169:                     *
1170:                     * PreCondition:    pStat   - valid pointer
1171:                     *
1172:                     * Input:           pStat   - pointer to a DmaStatus structure to store the current DMA controller
1173:                     *                          status, carrying the following info:
1174:                     *                              - chn:  the last active DMA channel
1175:                     *                              - rdOp: the last DMA operation, read/write
1176:                     *                              - lastAddress: the most recent DMA address
1177:                     *
1178:                     * Output:          None
1179:                     *
1180:                     * Side Effects:    None
1181:                     *
1182:                     * Overview:        The function updates the info for the current DMA controller status.
1183:                     *                  It updates the last DMA: operation, channel used and address.
1184:                     *
1185:                     * Note:            None.
1186:                     *
1187:                     * Example:         DmaStatus stat; DmaGetStatus(&stat);
1188:                     ********************************************************************/
1189:                     void           DmaGetStatus(DmaStatus* pStat);
1190:                
1191:                    /*********************************************************************
1192:                     * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1193:                     *
1194:                     * PreCondition:    None
1195:                     *
1196:                     * Input:           gFlags - flags to be set, having the following fields:
1197:                     *          - DMA_GFLG_SUSPEND: DMA controller operation suspend
1198:                     *          - DMA_GFLG_ON: DMA controller enabled/desabled
1199:                     *          - DMA_GFLG_ALL_FLAGS: all flags
1200:                     *
1201:                     * Output:          None
1202:                     *
1203:                     * Side Effects:    None
1204:                     *
1205:                     * Overview:        The function affects the global behavior of the DMA controller.
1206:                     *                  It sets the specified flags. Any flag that is set in the gFlags will be
1207:                     *                  enabled, the other flags won't be touched.
1208:                     *
1209:                     * Note:            None.
1210:                     *
1211:                     * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1212:                     ********************************************************************/
1213:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1214:                    {
1215:                        DMACONSET=gFlags;
1216:                    }
1217:                
1218:                    /*********************************************************************
1219:                     * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1220:                     *
1221:                     * PreCondition:    None
1222:                     *
1223:                     * Input:           gFlags - flags to be cleared, having the following fields:
1224:                     *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1225:                     *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1226:                     *                               - DMA_GFLG_ALL_FLAGS: all flags
1227:                     *
1228:                     * Output:          None
1229:                     *
1230:                     * Side Effects:    None
1231:                     *
1232:                     * Overview:        The function affects the global behavior of the DMA controller.
1233:                     *                  It clears the specified flags. Any flag that is set in the gFlags will be
1234:                     *                  cleared, the other flags won't be touched.
1235:                     *
1236:                     * Note:            None.
1237:                     *
1238:                     * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1239:                     ********************************************************************/
1240:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1241:                    {
1242:                        DMACONCLR=gFlags;
1243:                    }
1244:                
1245:                
1246:                    /*********************************************************************
1247:                     * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1248:                     *
1249:                     * PreCondition:    None
1250:                     *
1251:                     * Input:           gFlags - flags to be set, having the following fields:
1252:                     *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1253:                     *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1254:                     *                                 - DMA_GFLG_ALL_FLAGS: all flags
1255:                     *
1256:                     * Output:          None
1257:                     *
1258:                     * Side Effects:    None
1259:                     *
1260:                     * Overview:        The function affects the global behavior of the DMA controller.
1261:                     *                  It forces the flags to have the specified gFlags value.
1262:                     *
1263:                     * Note:            None.
1264:                     *
1265:                     * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1266:                     ********************************************************************/
1267:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1268:                    {
1269:                        DMACON=gFlags;
1270:                    }
1271:                
1272:                    /*********************************************************************
1273:                     * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1274:                     *
1275:                     * PreCondition:    None
1276:                     *
1277:                     * Input:           None
1278:                     *
1279:                     * Output:          The current DMA controller flags settings.
1280:                     *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1281:                     *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1282:                     *
1283:                     * Side Effects:    None
1284:                     *
1285:                     * Overview:        The function returns the global flags of the DMA controller.
1286:                     *
1287:                     * Note:            None.
1288:                     *
1289:                     * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1290:                     ********************************************************************/
1291:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1292:                    {
1293:                        return (DmaGlblFlags)DMACON;
1294:                    }
1295:                
1296:                
1297:                    /*********************************************************************
1298:                     * Function:        int DmaGetMaxTxferSize(void)
1299:                     *
1300:                     * PreCondition:    None
1301:                     *
1302:                     * Input:           None
1303:                     *
1304:                     * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1305:                     *
1306:                     * Side Effects:    None
1307:                     *
1308:                     * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1309:                     *
1310:                     * Note:            Revision dependant.
1311:                     *
1312:                     * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1313:                     ********************************************************************/
1314:                    extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1315:                    {
1316:                        return 65536;
1317:                    }
1318:                
1319:                    // Direct Channel control functions
1320:                
1321:                    typedef enum
1322:                    {
1323:                        DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1324:                        DMA_CONFIG_AUTO = _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1325:                        DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK), // DMA channel is chained to lower channel
1326:                        DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),       // DMA channel is chained to higher channel
1327:                        DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,            // events detection enabled while channel off
1328:                        DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,             // DMA channel is enabled after open
1329:                        DMA_CONFIG_MATCH    = 0x80000000,                   // DMA channel stops on match
1330:                    }DmaConfigFlags;    // flags for the channel configuration
1331:                
1332:                
1333:                
1334:                    /*********************************************************************
1335:                     * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1336:                     *
1337:                     * PreCondition:    chPri  - valid channel priority, 0-3
1338:                     *
1339:                     * Input:           chn    - channel to be configured in the DMA controller
1340:                     *                  chPri  - the priority given to the channel, 0-3
1341:                     *                  cFlags - orred flags specifying the configuration:
1342:                     *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1343:                     *                           DMA_CONFIG_AUTO:   DMA channel is auto enabled
1344:                     *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1345:                     *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1346:                     *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1347:                     *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1348:                     *                           DMA_CONFIG_MATCH:  DMA channel stops on match
1349:                     *
1350:                     *
1351:                     *
1352:                     * Output:          None
1353:                     *
1354:                     * Side Effects:    None
1355:                     *
1356:                     * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1357:                     *
1358:                     * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1359:                     *                  The channel is just configured.
1360:                     *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1361:                     *                  if DMA_CONFIG_ENABLE flag was not specified.
1362:                     *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1363:                     *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1364:                     *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1365:                     *                  User has to call event channel functions to clear/enable the event flags if needed.
1366:                     *
1367:                     * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1368:                     ********************************************************************/
1369:                    void            DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1370:                
1371:                
1372:                    /*********************************************************************
1373:                     * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1374:                     *
1375:                     * PreCondition:    chn - valid DMA channel
1376:                     *
1377:                     * Input:           chn     - DMA channel number
1378:                     *
1379:                     * Output:          Current channel source pointer.
1380:                     *
1381:                     * Side Effects:    None
1382:                     *
1383:                     * Overview:        The function retrieves the current source pointer for the selected DMA channel.
1384:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1385:                     *
1386:                     * Note:            None
1387:                     *
1388:                     * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1389:                     ********************************************************************/
1390:                     int            DmaChnGetSrcPnt(DmaChannel chn);
1391:                
1392:                    /*********************************************************************
1393:                     * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1394:                     *
1395:                     * PreCondition:    chn - valid DMA channel
1396:                     *
1397:                     * Input:           chn     - DMA channel number
1398:                     *
1399:                     * Output:          Current channel destination pointer.
1400:                     *
1401:                     * Side Effects:    None
1402:                     *
1403:                     * Overview:        The function retrieves the current destination pointer for the selected DMA channel.
1404:                     *                  It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1405:                     *
1406:                     * Note:            None
1407:                     *
1408:                     * Example:         int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1409:                     ********************************************************************/
1410:                     int            DmaChnGetDstPnt(DmaChannel chn);
1411:                
1412:                    /*********************************************************************
1413:                     * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1414:                     *
1415:                     * PreCondition:    chn - valid DMA channel
1416:                     *
1417:                     * Input:           chn     - DMA channel number
1418:                     *
1419:                     * Output:          Current channel transfer pointer.
1420:                     *
1421:                     * Side Effects:    None
1422:                     *
1423:                     * Overview:        The function retrieves the current transfer progress pointer for the selected DMA channel.
1424:                     *                  It ranges 0 to DmaGetMaxTxferSize()-1.
1425:                     *
1426:                     * Note:            None
1427:                     *
1428:                     * Example:         int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1429:                     ********************************************************************/
1430:                     int            DmaChnGetCellPnt(DmaChannel chn);
1431:                
1432:                
1433:                
1434:                    /*********************************************************************
1435:                     * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1436:                     *
1437:                     * PreCondition:    chn - valid DMA channel
1438:                     *
1439:                     * Input:           chn         - DMA channel number
1440:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1441:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1442:                     *                                      - SIRQEN: enable/disable the start IRQ action
1443:                     *                                      - PATEN: enable/disable the pattern match and abort
1444:                     *                                  or any of the DmaEvCtrlFlags:
1445:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1446:                     *
1447:                     *
1448:                     * Output:          None
1449:                     *
1450:                     * Side Effects:    None
1451:                     *
1452:                     * Overview:        The function sets the events that start and abort the transfer
1453:                     *                  for the selected DMA channel.
1454:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1455:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1456:                     *
1457:                     * Note:            None.
1458:                     *
1459:                     * Example:         either:
1460:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1461:                     *                  or:
1462:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1463:                     *                      DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1464:                     *
1465:                     ********************************************************************/
1466:                     void           DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1467:                
1468:                
1469:                    /*********************************************************************
1470:                     * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1471:                     *
1472:                     * PreCondition:    chn - valid DMA channel
1473:                     *
1474:                     * Input:           chn         - DMA channel number
1475:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1476:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1477:                     *                                      - SIRQEN: enable/disable the start IRQ action
1478:                     *                                      - PATEN: enable/disable the pattern match and abort
1479:                     *                                  or any of the DmaEvCtrlFlags:
1480:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1481:                     *
1482:                     *
1483:                     * Output:          None
1484:                     *
1485:                     * Side Effects:    None
1486:                     *
1487:                     * Overview:        The function clears the events that start and abort the transfer
1488:                     *                  for the selected DMA channel.
1489:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1490:                     *                  disabled for the selected channel, the other channel event flags won't be touched.
1491:                     *
1492:                     * Note:            None.
1493:                     *
1494:                     * Example:         either:
1495:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1496:                     *                  or:
1497:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1498:                     *                      DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1499:                     *
1500:                     ********************************************************************/
1501:                     void           DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1502:                
1503:                
1504:                
1505:                    /*********************************************************************
1506:                     * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1507:                     *
1508:                     * PreCondition:    chn - valid DMA channel
1509:                     *
1510:                     * Input:           chn         - DMA channel number
1511:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1512:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1513:                     *                                      - SIRQEN: enable/disable the start IRQ action
1514:                     *                                      - PATEN: enable/disable the pattern match and abort
1515:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1516:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1517:                     *                                  or any of the DmaEvCtrlFlags:
1518:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1519:                     *
1520:                     *
1521:                     * Output:          None
1522:                     *
1523:                     * Side Effects:    None
1524:                     *
1525:                     * Overview:        The function writes the events that start and abort the transfer
1526:                     *                  for the selected DMA channel.
1527:                     *
1528:                     * Note:            None.
1529:                     *
1530:                     * Example:         either:
1531:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1532:                     *                  or:
1533:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1534:                     *                      DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1535:                     *
1536:                     ********************************************************************/
1537:                     void           DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1538:                
1539:                
1540:                
1541:                    /*********************************************************************
1542:                     * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1543:                     *
1544:                     * PreCondition:    chn - valid DMA channel
1545:                     *
1546:                     * Input:           chn         - DMA channel number
1547:                     *                  dmaEvCtrl   -   either a DmaEvCtrl structure field, carrying the following info:
1548:                     *                                      - AIRQEN: enable/disable the abort IRQ action
1549:                     *                                      - SIRQEN: enable/disable the start IRQ action
1550:                     *                                      - PATEN: enable/disable the pattern match and abort
1551:                     *                                      - CHSIRQ: IRQ number to start the DMA channel transfer
1552:                     *                                      - CHAIRQ: IRQ number to abort the DMA channel transfer
1553:                     *                                  or any of the DmaEvCtrlFlags:
1554:                     *                                      DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1555:                     *
1556:                     *
1557:                     * Output:          None
1558:                     *
1559:                     * Side Effects:    None
1560:                     *
1561:                     * Overview:        The function sets the events that start and abort the transfer
1562:                     *                  for the selected DMA channel.
1563:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1564:                     *                  enabled for the selected channel, the other channel event flags won't be touched.
1565:                     *
1566:                     * Note:           A shorter name for DmaChnWriteEventControlFlags();
1567:                     *
1568:                     * Example:         either:
1569:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1570:                     *                  or:
1571:                     *                      DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1572:                     *                      DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1573:                     *
1574:                     ********************************************************************/
1575:                    #define         DmaChnSetEventControl(chn, dmaEvCtrl)   DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1576:                
1577:                
1578:                    /*********************************************************************
1579:                     * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1580:                     *
1581:                     * PreCondition:    chn - valid DMA channel
1582:                     *
1583:                     * Input:           chn     - DMA channel number
1584:                     *
1585:                     * Output:          -   either a DmaEvCtrl structure field, carrying the following info:
1586:                     *                          - AIRQEN: enable/disable the abort IRQ action
1587:                     *                          - SIRQEN: enable/disable the start IRQ action
1588:                     *                          - PATEN: enable/disable the pattern match and abort
1589:                     *                          - CHSIRQ: IRQ number to start the DMA channel transfer
1590:                     *                          - CHAIRQ: IRQ number to abort the DMA channel transfer
1591:                     *                      or any of the DmaEvCtrlFlags:
1592:                     *                          DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1593:                     *
1594:                     *
1595:                     * Side Effects:    None
1596:                     *
1597:                     * Overview:        The function retrieves the events that start and abort the transfer
1598:                     *                  for the selected DMA channel.
1599:                     *
1600:                     * Note:            None.
1601:                     *
1602:                     * Example:         either:
1603:                     *                      DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1604:                     *                  or:
1605:                     *                      DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1606:                     *
1607:                     ********************************************************************/
1608:                     DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn);
1609:                
1610:                
1611:                    /*********************************************************************
1612:                     * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1613:                     *
1614:                     * PreCondition:    chn - valid DMA channel
1615:                     *
1616:                     * Input:           chn         - DMA channel number
1617:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1618:                     *                                      - autoEn: enable/disable the automatic mode
1619:                     *                                      - chainEn: enable/disable channel chaining
1620:                     *                                      - detectEn: enable/disable events detection when channel disabled
1621:                     *                                      - chEn: enable/disable channel functionality
1622:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1623:                     *                                  or any of the DmaChnCtrlFlags flags:
1624:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1625:                     *
1626:                     * Output:          None
1627:                     *
1628:                     * Side Effects:    None
1629:                     *
1630:                     * Overview:        The function sets the selected DMA channel control flags:
1631:                     *                  the chaining or auto mode, and events detection.
1632:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1633:                     *                  set for the selected channel, the other channel control flags won't be touched.
1634:                     *
1635:                     * Note:            None.
1636:                     *
1637:                     * Example:         either:
1638:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1639:                     *                  or:
1640:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1641:                     *                      DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1642:                     *
1643:                     ********************************************************************/
1644:                     void           DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1645:                
1646:                    /*********************************************************************
1647:                     * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1648:                     *
1649:                     * PreCondition:    chn - valid DMA channel
1650:                     *
1651:                     * Input:           chn         - DMA channel number
1652:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1653:                     *                                      - autoEn: enable/disable the automatic mode
1654:                     *                                      - chainEn: enable/disable channel chaining
1655:                     *                                      - detectEn: enable/disable events detection when channel disabled
1656:                     *                                      - chEn: enable/disable channel functionality
1657:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1658:                     *                                  or any of the DmaChnCtrlFlags flags:
1659:                     *                                      DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1660:                     *
1661:                     * Output:          None
1662:                     *
1663:                     * Side Effects:    None
1664:                     *
1665:                     * Overview:        The function clears the selected DMA channel control flags:
1666:                     *                  the chaining or auto mode and events detection.
1667:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1668:                     *                  cleared for the selected channel, the other channel control flags won't be touched.
1669:                     *
1670:                     * Note:            None.
1671:                     *
1672:                     * Example:         either:
1673:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1674:                     *                  or:
1675:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1676:                     *                      DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1677:                     *
1678:                     ********************************************************************/
1679:                     void           DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1680:                
1681:                    /*********************************************************************
1682:                     * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1683:                     *
1684:                     * PreCondition:    chn - valid DMA channel
1685:                     *
1686:                     * Input:           chn         - DMA channel number
1687:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1688:                     *                                      - chPri: channel priority 0-3
1689:                     *                                      - autoEn: enable/disable the automatic mode
1690:                     *                                      - chainEn: enable/disable channel chaining
1691:                     *                                      - detectEn: enable/disable events detection when channel disabled
1692:                     *                                      - chEn: enable/disable channel functionality
1693:                     *                                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1694:                     *                                  or any of the DmaChnCtrlFlags flags:
1695:                     *                                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1696:                     *
1697:                     * Output:          None
1698:                     *
1699:                     * Side Effects:    None
1700:                     *
1701:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1702:                     *                  the channel priority, chaining mode or auto and events detection.
1703:                     *
1704:                     * Note:            None.
1705:                     *
1706:                     * Example:         either:
1707:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1708:                     *                  or:
1709:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1710:                     *                      DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1711:                     *
1712:                     ********************************************************************/
1713:                     void           DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1714:                
1715:                    /*********************************************************************
1716:                     * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1717:                     *
1718:                     * PreCondition:    chn - valid DMA channel
1719:                     *
1720:                     * Input:       chn     - DMA channel number
1721:                     *                  dmaChnCtrl  -   either a DmaChnCtrl structure field, carrying the following info:
1722:                     *                      - chPri: channel priority 0-3
1723:                     *                      - autoEn: enable/disable the automatic mode
1724:                     *                      - chainEn: enable/disable channel chaining
1725:                     *                      - detectEn: enable/disable events detection when channel disabled
1726:                     *                      - chEn: enable/disable channel functionality
1727:                     *                      - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1728:                     *                  or any of the DmaChnCtrlFlags flags:
1729:                     *                      DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1730:                     *
1731:                     * Output:          None
1732:                     *
1733:                     * Side Effects:    None
1734:                     *
1735:                     * Overview:        The function enables/disables the selected DMA channel and also sets
1736:                     *                  the channel priority, chaining mode or auto and events detection.
1737:                     *
1738:                     * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1739:                     *
1740:                     * Example:         either:
1741:                     *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1742:                     *                  or:
1743:                     *                      DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1744:                     *          DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1745:                     *
1746:                     ********************************************************************/
1747:                    #define     DmaChnSetControl(chn, dmaChnCtrl)   DmaChnWriteControlFlags(chn, dmaChnCtrl)
1748:                
1749:                    /*********************************************************************
1750:                     * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1751:                     *
1752:                     * PreCondition:    chn - valid DMA channel
1753:                     *
1754:                     * Input:           chn         - DMA channel number
1755:                     *
1756:                     * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1757:                     *                          - chPri: channel priority 0-3
1758:                     *                          - autoEn: enable/disable the automatic mode
1759:                     *                          - chainEn: enable/disable channel chaining
1760:                     *                          - detectEn: enable/disable events detection when channel disabled
1761:                     *                          - chEn: enable/disable channel functionality
1762:                     *                          - chainDir: chain direction: chain to lower(1)/higher(0),pri channel
1763:                     *                      or any of the DmaChnCtrlFlags flags:
1764:                     *                          DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1765:                     *
1766:                     * Side Effects:    None
1767:                     *
1768:                     * Overview:        The function retrieves the current control settings for the selected DMA channel,
1769:                     *                  including the channel enable/disable status, the channel priority,
1770:                     *                  chaining mode, auto mode and events detection.
1771:                     *
1772:                     * Note:            None.
1773:                     *
1774:                     * Example:         either:
1775:                     *                      DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1776:                     *                  or:
1777:                     *                      DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1778:                     *
1779:                     ********************************************************************/
1780:                     DmaChnCtrlFlags    DmaChnGetControlFlags(DmaChannel chn);
1781:                
1782:                
1783:                    /*********************************************************************
1784:                     * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1785:                     *
1786:                     * PreCondition:    chn - valid DMA channel
1787:                     *
1788:                     * Input:           chn     - DMA channel number
1789:                     *
1790:                     * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1791:                     *
1792:                     * Side Effects:    None
1793:                     *
1794:                     * Overview:        The function returns the current event detection for the selected DMA channel.
1795:                     *
1796:                     * Note:            None.
1797:                     *
1798:                     * Example:         int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1799:                     *
1800:                     ********************************************************************/
1801:                     int            DmaChnGetEvDetect(DmaChannel chn);
1802:                
1803:                    /*********************************************************************
1804:                     * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1805:                     *
1806:                     * PreCondition:    chn     - valid DMA channel
1807:                     *                  pTxCtrl - valid pointer
1808:                     *
1809:                     * Input:           chn         - DMA channel number
1810:                     *                  pTxCtrl     - pointer to a DmaTxferCtrl that will carry the following info:
1811:                     *                              - vSrcAdd: source of the DMA transfer
1812:                     *                              - vDstAdd: destination of the DMA transfer
1813:                     *                              - srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1814:                     *                              - dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1815:                     *                              - cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1816:                     *                  mapToK0     - if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1817:                     *
1818:                     * Output:          None
1819:                     *
1820:                     * Side Effects:    None
1821:                     *
1822:                     * Overview:        The function retrieves the transfer characteristics for a DMA channel transfer:
1823:                     *                  the source and the destination addresses.
1824:                     *                  It also retrieves the source and destination lengths
1825:                     *                  and the number of bytes transferred per event.
1826:                     *
1827:                     * Note:            None
1828:                     *
1829:                     * Example:         DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1830:                     ********************************************************************/
1831:                     void           DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1832:                
1833:                    // Low level checksum functions
1834:                
1835:                    /*********************************************************************
1836:                     * Function:        void DmaSfmEnable(int enable)
1837:                     *
1838:                     * PreCondition:    None
1839:                     *
1840:                     * Input:           enable _ boolean to enable/disable the SFM functionality
1841:                     *
1842:                     * Output:          None
1843:                     *
1844:                     * Side Effects:    None
1845:                     *
1846:                     * Overview:        The function enables/diables the checksum module functionality.
1847:                     *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1848:                     *
1849:                     * Note:            The SFM module should be properly configured before enabled.
1850:                     *
1851:                     * Example:         DmaSfmEnable(1);
1852:                     ********************************************************************/
1853:                    extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1854:                    {
1855:                        if(enable)
1856:                        {
1857:                            DCRCCONSET=_DCRCCON_CRCEN_MASK;
1858:                        }
1859:                        else
1860:                        {
1861:                            DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1862:                        }
1863:                    }
1864:                    #define DmaCrcEnable    DmaSfmEnable        // PIC32_3xx backward compatibility
1865:                
1866:                
1867:                    /*********************************************************************
1868:                     * Function:        int DmaSfmGetEnable(void)
1869:                     *
1870:                     * PreCondition:    None
1871:                     *
1872:                     * Input:           None
1873:                     *
1874:                     * Output:          TRUE, if the SFM module is enabled
1875:                     *          FALSE otherwise
1876:                     *
1877:                     * Side Effects:    None
1878:                     *
1879:                     * Overview:        The function returns the SFM module enabling status.
1880:                     *
1881:                     * Note:            None
1882:                     *
1883:                     * Example:     int isSfmEnabled=DmaSfmGetEnable();
1884:                     ********************************************************************/
1885:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1886:                    {
1887:                        return DCRCCONbits.CRCEN!=0;
1888:                    }
1889:                    #define     DmaCrcGetEnable     DmaSfmGetEnable     // PIC32_3xx backward compatibility
1890:                
1891:                
1892:                    /*********************************************************************
1893:                     * Function:        void DmaSfmAppendEnable(int enable)
1894:                     *
1895:                     * PreCondition:    None
1896:                     *
1897:                     * Input:           enable _ boolean to enable/disable the SFM append mode
1898:                     *
1899:                     * Output:          None
1900:                     *
1901:                     * Side Effects:    None
1902:                     *
1903:                     * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1904:                     *                  the source data but does not write it to the destination address. The data it's just passed
1905:                     *                  to the checksum generator for CRC/IP checksum calculation.
1906:                     *                  When the block transfer is completed, the checksum result is written to the
1907:                     *                  DMA channel destination address.
1908:                     *
1909:                     * Note:            The SFM module should be properly configured before enabled.
1910:                     *
1911:                     * Example:         DmaSfmAppendModeEnable(TRUE);
1912:                     ********************************************************************/
1913:                    extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1914:                    {
1915:                        if(enable)
1916:                        {
1917:                            DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1918:                        }
1919:                        else
1920:                        {
1921:                            DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1922:                        }
1923:                    }
1924:                    #define     DmaCrcAppendModeEnable  DmaSfmAppendEnable  // PIC32_3xx backward compatibility
1925:                
1926:                
1927:                    /*********************************************************************
1928:                     * Function:        int DmaSfmGetAppendMode(void)
1929:                     *
1930:                     * PreCondition:    None
1931:                     *
1932:                     * Input:           None
1933:                     *
1934:                     * Output:          TRUE, if the SFM append mode is enabled
1935:                     *                  FALSE otherwise
1936:                     *
1937:                     * Side Effects:    None
1938:                     *
1939:                     * Overview:        The function returns the SFM module enabling status.
1940:                     *
1941:                     * Note:            None
1942:                     *
1943:                     * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1944:                     ********************************************************************/
1945:                    extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1946:                    {
1947:                        return DCRCCONbits.CRCAPP!=0;
1948:                    }
1949:                    #define DmaCrcGetAppendMode DmaSfmGetAppendMode     // PIC32_3xx backward compatibility
1950:                
1951:                
1952:                    /*********************************************************************
1953:                     * Function:        void DmaSfmSetAttach(DmaChannel chn)
1954:                     *
1955:                     * PreCondition:    chn     - valid DMA channel
1956:                     *
1957:                     * Input:           chn - the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1958:                     *
1959:                     * Output:          None
1960:                     *
1961:                     * Side Effects:    None
1962:                     *
1963:                     * Overview:        The function directly attaches a DMA channel to the SFM module.
1964:                     *
1965:                     * Note:            None
1966:                     *
1967:                     * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1968:                     ********************************************************************/
1969:                    extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1970:                    {
1971:                        DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1972:                        DCRCCONSET=chn;
1973:                    }
1974:                    #define     DmaCrcSetAttach     DmaSfmSetAttach     // PIC32_3xx backward compatibility
1975:                
1976:                
1977:                    /*********************************************************************
1978:                     * Function:        DmaChannel DmaSfmGetAttach(void)
1979:                     *
1980:                     * PreCondition:    None
1981:                     *
1982:                     * Input:           None
1983:                     *
1984:                     * Output:          the DMA channel that is currently attached to the CRC module
1985:                     *
1986:                     * Side Effects:    None
1987:                     *
1988:                     * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1989:                     *
1990:                     * Note:            None
1991:                     *
1992:                     * Example:         DmaChannel chn=DmaSfmGetAttach();
1993:                     ********************************************************************/
1994:                    extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1995:                    {
1996:                        return (DmaChannel)DCRCCONbits.CRCCH;
1997:                    }
1998:                    #define     DmaCrcGetAttach     DmaSfmGetAttach     // PIC32_3xx backward compatibility
1999:                
2000:                    /*********************************************************************
2001:                     * Function:        void DmaCrcSetPLen(int pLen)
2002:                     *
2003:                     * PreCondition:    pLen - valid polynomial length within 1-32
2004:                     *
2005:                     * Input:           pLen    - the length of the CRC generator polynomial
2006:                     *
2007:                     * Output:          None
2008:                     *
2009:                     * Side Effects:    None
2010:                     *
2011:                     * Overview:        The length of the CRC generator polynomial is set as being pLen;
2012:                     *
2013:                     * Note:            None
2014:                     *
2015:                     * Example:         DmaCrcSetPLen(32);
2016:                     ********************************************************************/
2017:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2018:                    {
2019:                        DCRCCONCLR=_DCRCCON_PLEN_MASK;
2020:                        DCRCCONSET=(pLen)-1;
2021:                    }
2022:                
2023:                    /*********************************************************************
2024:                     * Function:        int DmaCrcGetPLen(void)
2025:                     *
2026:                     * PreCondition:    None
2027:                     *
2028:                     * Input:           None
2029:                     *
2030:                     * Output:          the length of the CRC generator polynomial
2031:                     *
2032:                     * Side Effects:    None
2033:                     *
2034:                     * Overview:        The function returns the current length of the CRC generator polynomial.
2035:                     *                  It's always a number between 1 and 32.
2036:                     *
2037:                     * Note:            None
2038:                     *
2039:                     * Example:         int polyLen=DmaCrcGetPLen();
2040:                     ********************************************************************/
2041:                    extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2042:                    {
2043:                        return  DCRCCONbits.PLEN+1;
2044:                    }
2045:                
2046:                    /*********************************************************************
2047:                     * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2048:                     *
2049:                     * PreCondition:    None
2050:                     *
2051:                     * Input:           feedback - the layout of the CRC generator
2052:                     *
2053:                     * Output:          None
2054:                     *
2055:                     * Side Effects:    None
2056:                     *
2057:                     * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2058:                     *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2059:                     *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2060:                     *
2061:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2062:                     *
2063:                     * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2064:                     ********************************************************************/
2065:                    extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2066:                    {
2067:                        DCRCXOR=feedback;
2068:                    }
2069:                
2070:                
2071:                    /*********************************************************************
2072:                     * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2073:                     *
2074:                     * PreCondition:    None
2075:                     *
2076:                     * Input:           None
2077:                     *
2078:                     * Output:          the current layout of the CRC generator
2079:                     *
2080:                     * Side Effects:    None
2081:                     *
2082:                     * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2083:                     *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2084:                     *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2085:                     *
2086:                     * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2087:                     *
2088:                     * Example:         int feedback=DmaCrcGetShiftFeedback();
2089:                     ********************************************************************/
2090:                    extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2091:                    {
2092:                        return DCRCXOR;
2093:                    }
2094:                
2095:                
2096:                
2097:                    // Channel test/debug and special functions
2098:                
2099:                    /*********************************************************************
2100:                     * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2101:                     *
2102:                     * PreCondition:    chn - valid DMA channel
2103:                     *
2104:                     * Input:           chn     - DMA channel number
2105:                     *                  eFlags  - event flags with the following significance:
2106:                     *                              - DMA_EV_ERR: address error event
2107:                     *                              - DMA_EV_ABORT: transfer abort event
2108:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2109:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2110:                     *                              - DMA_EV_DST_HALF: destination half event
2111:                     *                              - DMA_EV_DST_FULL: destination full event
2112:                     *                              - DMA_EV_SRC_HALF: source half event
2113:                     *                              - DMA_EV_SRC_FULL: source full event
2114:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2115:                     *
2116:                     * Output:          None
2117:                     *
2118:                     * Side Effects:    None
2119:                     *
2120:                     * Overview:        The function sets the event flags for the selected DMA channel.
2121:                     *                  Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2122:                     *                  set for the selected channel, the other channel event flags won't be touched.
2123:                     *
2124:                     * Note:            This is intended as a channel test function.
2125:                     *
2126:                     * Example:         DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2127:                     ********************************************************************/
2128:                     void           DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2129:                
2130:                    /*********************************************************************
2131:                     * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2132:                     *
2133:                     * PreCondition:    chn - valid DMA channel
2134:                     *
2135:                     * Input:           chn     - DMA channel number
2136:                     *                  eFlags  - event flags with the following significance:
2137:                     *                              - DMA_EV_ERR: address error event
2138:                     *                              - DMA_EV_ABORT: transfer abort event
2139:                     *                              - DMA_EV_CELL_DONE: cell transfer complete event
2140:                     *                              - DMA_EV_BLOCK_DONE: block transfer complete event
2141:                     *                              - DMA_EV_DST_HALF: destination half event
2142:                     *                              - DMA_EV_DST_FULL: destination full event
2143:                     *                              - DMA_EV_SRC_HALF: source half event
2144:                     *                              - DMA_EV_SRC_FULL: source full event
2145:                     *                              - DMA_EV_ALL_EVNTS: all of the above flags
2146:                     *
2147:                     * Output:          None
2148:                     *
2149:                     * Side Effects:    None
2150:                     *
2151:                     * Overview:        The function writes the event flags for the selected DMA channel.
2152:                     *                  The channel event flags are forced to the eFlags value.
2153:                     *
2154:                     * Note:            This is intended as a channel test function.
2155:                     *
2156:                     * Example:         DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2157:                     ********************************************************************/
2158:                     void           DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2159:                
2160:                
2161:                    /********************************************************************
2162:                     * Include legacy DMA functions
2163:                     * New projects should not use them!
2164:                     * Note that interrupt functions are no longer provided.
2165:                     * The functions in the int.h should be used instead.
2166:                     ********************************************************************/
2167:                    #ifndef _PLIB_DISABLE_LEGACY
2168:                        #include <peripheral/legacy/dma_legacy.h>
2169:                    #endif
2170:                
2171:                
2172:                #else
2173:                    #undef _DMA_CHANNELS        // no DMA channels
2174:                #endif  // _DMAC0
2175:                
2176:                #endif /*_DMA_5XX_6XX__7XX_H_*/
2177:                
2178:                
